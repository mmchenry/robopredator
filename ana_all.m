function ana_all(root_path)
% Performs analyses on the data in 'flow_along_body.mat', which is
% generated by ana_body_flow.m



%% Code execution

% Create boxplots of each parameter that could serve as a cue
do_boxplots = 0;

% Plots 3D volumes of flow field and responses
do_3D = 0;

% Compares the direction of flow gradient to direction of behavior
do_directioncue = 0;

% Visualize results of direction cue
vis_directcue = 1;

% Descriptive stats of directional response
do_direction = 1;

% Visualize individual sequences
vis_seqs = 0;


%% Parameters

% Period between detection and fast start initiation (s)
latency = 5e-3;

% Modeled threshold of shearing for a response
sh_thresh = .5;

% Modeled threshold of speed
spd_thresh = .1;

% Relative position of COM along length of the body (this is Matt's guess)
COM_pos = .25;

% Alpha transparency for the isosurface plots
alpha_val = .6;

% Inerval for skipping plotting of normal vectors
norm_skip = 100;

% Scaling of body length for CFD volume examine for isosurface
sclfactr = .25;


%% Paths

if nargin < 1
    root_path = uigetdir(pwd,'Select root directory (holds "cfd" & "behavior")');
end

% Paths to CFD data arranged in regular grid
cfd_path{1}  = [root_path filesep 'cfd' filesep 'flow_02cmps_reggrid.mat'];
cfd_path{2}  = [root_path filesep 'cfd' filesep 'flow_11cmps_reggrid.mat'];
cfd_path{3}  = [root_path filesep 'cfd' filesep 'flow_20cmps_reggrid.mat'];


%% Load data & define variables

% Load flow data ('f')
load([root_path filesep 'behavior' filesep 'flow_along_body.mat'])

% Load behavior data ('b')
load([root_path filesep 'behavior' filesep 'Transformed_Prey_Coords.mat'])

% Number of sequences
num_seq = length(b.preyx(:,1));

% Values of speeds
spds = [2 11 20];

% Indices for each speed of sequences in the dark, with lateral line intact
index{1} = (b.speed(1:num_seq)==2) & (b.LL(1:num_seq)==1) ...
     & ~isnan(b.preyx(:,1)) & (b.lit(1:num_seq)==0);

index{2} = (b.speed(1:num_seq)==11) & (b.LL(1:num_seq)==1) ...
     & ~isnan(b.preyx(:,1)) & (b.lit(1:num_seq)==0);
 
index{3} = (b.speed(1:num_seq)==20) & (b.LL(1:num_seq)==1) ...
     & ~isnan(b.preyx(:,1)) & (b.lit(1:num_seq)==0);

% Create groups by speed
groups = [b.speed(index{1}); b.speed(index{2}); b.speed(index{3})];


%% Response boxplots


if do_boxplots
    
%     % Distance of each of the three body points
%     dist1 = sqrt( b.preyx(:,1).^2 + b.preyy(:,1).^2 + b.preyz(:,1).^2 );
%     dist2 = sqrt( b.preyx(:,2).^2 + b.preyy(:,2).^2 + b.preyz(:,2).^2 );
%     dist3 = sqrt( b.preyx(:,3).^2 + b.preyy(:,3).^2 + b.preyz(:,3).^2 );
%     
%     % Use minimum distance as the response distance
%     resp_dist = min([dist1 dist2 dist3],[],2);
    
    % Max speed along body for each speed
    max_bod_spd =  [max(f.spd(index{1},:),[],2); ...
        max(f.spd(index{2},:),[],2); ...
        max(f.spd(index{3},:),[],2)];
    
    % Max velocity gradient along body for each speed
    max_velgrad =  [max(abs(f.velgrad(index{1},:)),[],2); ...
        max(abs(f.velgrad(index{2},:)),[],2); ...
        max(abs(f.velgrad(index{3},:)),[],2)];
    
    % Max shearing along body for each speed
    max_shear   =  [max(f.shrdef(index{1},:),[],2); ...
        max(f.shrdef(index{2},:),[],2); ...
        max(f.shrdef(index{3},:),[],2)];
    
    % Boxplots
    figure;
    
    subplot(2,2,1)
    boxplot(max_bod_spd, groups)
    xlabel('speed (cm/s)')
    ylabel('max speed along body')
    
    subplot(2,2,2)
    boxplot(max_velgrad, groups)
    xlabel('speed (cm/s)')
    ylabel('max vel gradient along body')
    
    subplot(2,2,3)
    boxplot(max_shear, groups)
    xlabel('speed (cm/s)')
    ylabel('max shear deformation along body')  
    
    clear dist1 dist2 dist3 resp_dist max_bod_spd max_velgrad max_shear
end


%% Plot spatial distibution of responders

if do_3D  
    
    % Step through each speed
    for i = 1:3
        
        % New Figure window
        figure
        
        % Load CFD data in 'cR' strcuture
        load(cfd_path{i})
        
        % 3D plot of speed and resposes -----------------------------------
        
        % Plot of position at response
        subplot(1,2,1)
        plot_prey_pos(f,index{i})
        hold on
        title(['Speed (' num2str(spds(i)) ' cm/s)'])
        xlims = xlim;
        ylims = ylim;
        zlims = zlim;
        
        hold on
        
        % Isosurface
        [faces,verts] = isosurface(cR.x,cR.y,cR.z,smooth3(cR.spd),spd_thresh);
        p = patch('Vertices', verts, 'Faces', faces, ...
                  'FaceColor','interp', ...
                  'edgecolor', 'interp');
        set(p,'FaceColor','red','EdgeColor','none');
        daspect([1,1,1])
        %view(3);
        axis tight
        camlight
        lighting gouraud
        alpha(p,alpha_val)
        
        % This is supposed to smooth the surface plot
        %isonormals(cR.x,cR.y,cR.z,cR.spd,p);       
        
        hold off
        
        % 3D plot of shearing and resposes --------------------------------
        
        % Plot of position at response
        subplot(1,2,2)
        plot_prey_pos(f,index{i})
        hold on
        title(['Shear deformation (' num2str(spds(i)) ' cm/s)'])
        xlims = xlim;
        ylims = ylim;
        zlims = zlim; 
        
        hold on
        
        % Isosurface
        p = patch(isosurface(cR.x,cR.y,cR.z,smooth3(cR.sh_def),sh_thresh));
        isonormals(cR.x,cR.y,cR.z,cR.sh_def,p)
        set(p,'FaceColor','red','EdgeColor','none');
        daspect([1,1,1])
        %view(3);
        axis tight
        camlight
        lighting gouraud
        alpha(p,alpha_val)
        
        hold off
        
    end   
    
end


%% Description of directional response


if do_direction
    
    % Number of bins used in rose plot
    num_bin = 20;
    
    % Initialize result vectors
    r.pred_spd = nan(size(b.preyx(:,1),1),1);
    r.th_pred  = nan(size(b.preyx(:,1),1),1);
    r.phi_pred = nan(size(b.preyx(:,1),1),1);
    r.th_meas  = nan(size(b.preyx(:,1),1),1);
    r.phi_meas = nan(size(b.preyx(:,1),1),1);
    r.az_prey  = nan(size(b.preyx(:,1),1),1);
    r.el_prey  = nan(size(b.preyx(:,1),1),1);
    
    for i = 1:3
        
        % Choose index for sequences that have stage 2 data
        idx = index{i} & ~isnan(b.preyx2(:,2)) & b.preyx(:,1)>0  ...
              & b.preyx(:,2)>0  & b.preyx(:,3)>0;
          
        % Offset in x, due to latency
        lat_offset = latency * spds(i);
          
        % Find position of prey
        prey_pos = [b.preyx(idx,2)+lat_offset b.preyy(idx,2) b.preyz(idx,2)];
        
        % Rostrum position
        rost_pos = [b.preyx(idx,1)+lat_offset b.preyy(idx,1) b.preyz(idx,1)];
        
        % Find direction of prey
        prey_dir(:,1) = b.preyx2(idx,1) - b.preyx(idx,1);
        prey_dir(:,2) = b.preyy2(idx,2) - b.preyy(idx,2);
        prey_dir(:,3) = b.preyz2(idx,3) - b.preyz(idx,3);
        
        % Transform prey position, assuming mirror symmetry about the predator
        prey_dir(prey_pos(:,2)<0,2) = -prey_dir(prey_pos(:,2)<0,2);  
        prey_pos(:,2)     = abs(prey_pos(:,2));
        
        % Spherical coordinates for prey position
        [prey_az,prey_el,prey_r] = cart2sph(prey_pos(:,1),...
                                            prey_pos(:,2),prey_pos(:,3));
                                        
        % Spherical coordinates for prey direction                                
        [dir_az,dir_el,dir_r] = cart2sph(prey_dir(:,1),...
                                            prey_dir(:,2),prey_dir(:,3));
                                        
        % Orientation of prey wrt predator on XY plane
        prey_orient = atan2(prey_pos(:,2)-rost_pos(:,2),...
                            prey_pos(:,1)-rost_pos(:,1));
                                        
        % Index of indivudual positioned ventral to predator
        i_vent = prey_pos(:,3)<=0;
        
        % Index of L-R responses in the 'wrong' direction
        i_wrong = prey_dir(:,2)<0;
        
        % Index of D-V responses in the 'wrong' direction
        i_wrongDV = (i_vent & (prey_dir(:,3)>0)) |  ...
                    (~i_vent & (prey_dir(:,3)<=0));
        
        if 1
            figure
            subplot(2,3,1)
            quiver(prey_pos(~i_wrong,1),prey_pos(~i_wrong,2),...
                   prey_dir(~i_wrong,1),prey_dir(~i_wrong,2),'b')
            hold on
            quiver(prey_pos(i_wrong,1),prey_pos(i_wrong,2),...
                   prey_dir(i_wrong,1),prey_dir(i_wrong,2),'r')
            hold off
            title([num2str(spds(i)) ' cm/s'])
            xlabel('x');ylabel('y')
            axis equal
            
            subplot(2,3,2)
            rose(dir_az(~i_vent & ~i_wrong),num_bin)
            hold on
            hR = rose(dir_az(~i_vent & i_wrong),num_bin);
            set(hR,'Color','r')
            hold off
            title('direction azimuth (dorsal)')
            
            subplot(2,3,3)
            rose(dir_az(i_vent & ~i_wrong),num_bin)
            hold on
            hR = rose(dir_az(i_vent & i_wrong),num_bin);
            set(hR,'Color','r')
            title('direction azimuth (ventral)')
            
            subplot(2,3,4)
            quiver(prey_pos(~i_wrongDV,1),prey_pos(~i_wrongDV,3),...
                   prey_dir(~i_wrongDV,1),prey_dir(~i_wrongDV,3),'b')
            hold on
            quiver(prey_pos(i_wrongDV,1),prey_pos(i_wrongDV,3),...
                   prey_dir(i_wrongDV,1),prey_dir(i_wrongDV,3),'r')
            hold off
            title([num2str(spds(i)) ' cm/s'])
            xlabel('x');ylabel('z')
            axis equal
            
            subplot(2,3,5)
            rose(dir_el(~i_vent & ~i_wrongDV),num_bin)
            hold on
            hR = rose(dir_el(~i_vent & i_wrongDV),num_bin);
            set(hR,'Color','r')
            hold off
            
            title('direction elevation (dorsal)')
            
            subplot(2,3,6)
            rose(dir_el(i_vent & ~i_wrongDV),num_bin)
            hold on
            hR = rose(dir_el(i_vent & i_wrongDV),num_bin);
            set(hR,'Color','r')
            hold off
            title('direction elevation (ventral)')
            
%             figure
%             plot(prey_orient(~i_wrong),'bo')
%             hold on
%             plot(prey_orient(i_wrong),'ro')
%             title([num2str(spds(i)) ' cm/s'])
%             hold off
        end
        
        clear prey_dir prey_pos lat_offset idx 
    end

end % do_direction


%% Anlayze flow cues that predict diretcion of response

if do_directioncue
    
    % Initialize result vectors
    r.pred_spd = nan(size(b.preyx(:,1),1),1);
    r.th_pred  = nan(size(b.preyx(:,1),1),1);
    r.phi_pred = nan(size(b.preyx(:,1),1),1);
    r.th_meas  = nan(size(b.preyx(:,1),1),1);
    r.phi_meas = nan(size(b.preyx(:,1),1),1);
    r.az_prey  = nan(size(b.preyx(:,1),1),1);
    r.el_prey  = nan(size(b.preyx(:,1),1),1);
    r.wrong    = zeros(size(b.preyx(:,1),1),1);
    r.vent     = zeros(size(b.preyx(:,1),1),1);
    
    % Loop through speeds
    for i = 1:3
        
        if vis_seqs
            figure;
        end
        
        % Choose index for sequences that have stage 2 data
        idx = index{i} & ~isnan(b.preyx2(:,2)) & b.preyx(:,1)>0  ...
              & b.preyx(:,2)>0  & b.preyx(:,3)>0;
        
        % Sequence numbers 
        seqs = find(idx);
        
        % Offset in x, due to latency
        lat_offset = latency * spds(i);
        
        % Load CFD data in 'cR' structure
        load(cfd_path{i})
        
        % Find position of prey
        prey_pos = [b.preyx(idx,2)+lat_offset b.preyy(idx,2) b.preyz(idx,2)];
        
        % Find direction of prey
        prey_dir(:,1) = b.preyx2(idx,1) - b.preyx(idx,1);
        prey_dir(:,2) = b.preyy2(idx,2) - b.preyy(idx,2);
        prey_dir(:,3) = b.preyz2(idx,3) - b.preyz(idx,3);
        
        % Transform prey position, assuming mirror symmetry about the predator
        prey_dir(prey_pos(:,2)<0,2) = -prey_dir(prey_pos(:,2)<0,2);  
        prey_pos(:,2)     = abs(prey_pos(:,2));
        
        % Index of indivudual positioned ventral to predator
        i_vent = prey_pos(:,3)<=0;
        
        % Index of L-R responses in the 'wrong' direction
        i_wrong = prey_dir(:,2)<0;
        
        % Step thru each sequence for current speed
        for j = 1:length(seqs)
            
            % Body length of prey
            blength = norm([b.preyx(seqs(j),3)-b.preyx(seqs(j),1) ...
                            b.preyy(seqs(j),3)-b.preyy(seqs(j),1) ...
                            b.preyz(seqs(j),3)-b.preyz(seqs(j),1)]);
           
            % Range of volume to interrogate
            rangeX   = [prey_pos(j,1)-blength*sclfactr ...
                        prey_pos(j,1)+blength*sclfactr];
            rangeY   = [prey_pos(j,2)-blength*sclfactr ...
                        prey_pos(j,2)+blength*sclfactr];
            rangeZ   = [prey_pos(j,3)-blength*sclfactr ...
                        prey_pos(j,3)+blength*sclfactr];
            subRange = [rangeX(1) rangeX(2) ...
                        rangeY(1) rangeY(2) ...
                        rangeZ(1) rangeZ(2)];
            
            % Reduce flow field to small volume
            [xS,yS,zS,spdS] = subvolume(cR.x,cR.y,cR.z,cR.spd,subRange);
            [xS,yS,zS,uS] = subvolume(cR.x,cR.y,cR.z,cR.u,subRange);
            [xS,yS,zS,vS] = subvolume(cR.x,cR.y,cR.z,cR.v,subRange);
            [xS,yS,zS,wS] = subvolume(cR.x,cR.y,cR.z,cR.w,subRange);
            [xS,yS,zS,xCS] = subvolume(cR.x,cR.y,cR.z,cR.xCurl,subRange);
            [xS,yS,zS,yCS] = subvolume(cR.x,cR.y,cR.z,cR.yCurl,subRange);
            [xS,yS,zS,zCS] = subvolume(cR.x,cR.y,cR.z,cR.zCurl,subRange);
            clear blength rangeX rangeY rangeZ subRange
            
            % Speed at the prey COM
            spd_prey = griddata(xS,yS,zS,spdS,prey_pos(j,1),prey_pos(j,2),prey_pos(j,3));
            
            % Velocity at the prey COM
            u_prey = griddata(xS,yS,zS,uS,prey_pos(j,1),prey_pos(j,2),prey_pos(j,3));
            v_prey = griddata(xS,yS,zS,vS,prey_pos(j,1),prey_pos(j,2),prey_pos(j,3));
            w_prey = griddata(xS,yS,zS,wS,prey_pos(j,1),prey_pos(j,2),prey_pos(j,3));
            
            % Curl at prey COM
            xC_prey = griddata(xS,yS,zS,xCS,prey_pos(j,1),prey_pos(j,2),prey_pos(j,3));
            yC_prey = griddata(xS,yS,zS,yCS,prey_pos(j,1),prey_pos(j,2),prey_pos(j,3));
            zC_prey = griddata(xS,yS,zS,zCS,prey_pos(j,1),prey_pos(j,2),prey_pos(j,3));
            
            % Isosurface in this small volume
            [faces,verts] = isosurface(xS,yS,zS,spdS,spd_prey);
            
            % Calculate normal vectors
            %[pos_norm,vect_norm] = cal_norms(faces,verts);
            
            % Distance between verticies and prey COM
%             dist = sqrt((pos_norm(:,1)-prey_pos(j,1)).^2 +  ...
%                         (pos_norm(:,2)-prey_pos(j,2)).^2 + ...
%                         (pos_norm(:,3)-prey_pos(j,3)).^2);
%                     
%             % Index for normal vector closest to the COM
%             i_norm = find(dist==min(dist));
            
            % Find index for flow data at COM
            %distCOM = abs(f.s(seqs(j),:)./max(f.s(seqs(j),:)) - COM_pos);
            %iCOM = find(distCOM == min(distCOM));
            
            
%              % Flow predicted diretcion, based on velocity and curl
%              tmp = cross([xC_prey,yC_prey,zC_prey],[u_prey,v_prey,w_prey]);
%              tmp = tmp./norm(tmp);
%              xPredict = tmp(1);yPredict = tmp(2);zPredict = tmp(3);
%             [th_pred,phi_pred,r_pred] = cart2sph(tmp(1),...
%                                                  tmp(2),...
%                                                  tmp(3));
            
            % Flow velocity at COM
            [th_pred,phi_pred,r_pred] = cart2sph(u_prey,...
                                                 v_prey,...
                                                 w_prey);
            % Calculate angles of predicted vector
%             [th_pred,phi_pred,r_pred] = cart2sph(vect_norm(i_norm,1),...
%                                                  vect_norm(i_norm,2),...
%                                                  vect_norm(i_norm,3));
            
            % Calculate angles of measured direction vector
            [th_meas,phi_meas,r_meas] = cart2sph(prey_dir(j,1),...
                                                 prey_dir(j,2),...
                                                 prey_dir(j,3));   
            % Calcuate angles of prey position
            [az_prey,el_prey,r_prey] = cart2sph(prey_pos(j,1),...
                                                prey_pos(j,2),...
                                                prey_pos(j,3));
            
            % Store result
            r.pred_spd(seqs(j)) = spds(i);                                
%             r.th_pred(seqs(j))  = th_pred *180/pi;
%             r.phi_pred(seqs(j)) = phi_pred*180/pi;
            r.th_meas(seqs(j))  = th_meas*180/pi;
            r.phi_meas(seqs(j)) = phi_meas*180/pi;
            r.az_prey(seqs(j))  = az_prey*180/pi;
            r.el_prey(seqs(j))  = el_prey*180/pi;
            r.th_pred(seqs(j))  = th_pred *180/pi;
            r.phi_pred(seqs(j)) = phi_pred *180/pi;
            r.wrong(seqs(j))    = i_wrong(j);
            r.vent(seqs(j))     = i_vent(j);
            
            
            % Visulaize this step (to confirm calculations
            if vis_seqs
                % Isosurface of speed
                p = patch('Vertices', verts, 'Faces', faces, ...
                    'FaceColor','interp', ...
                    'edgecolor', 'interp');
                set(p,'FaceColor','red','EdgeColor','none');
                daspect([1,1,1])
                %view(3);
                axis tight
                camlight
                lighting gouraud
                alpha(p,alpha_val)
                hold on
                
%                 quiver3(prey_pos(j,1),prey_pos(j,2),prey_pos(j,3),...
%                         xPredict,yPredict,zPredict,0.3,'b')
                
%                 % Normal vectors
%                 hq = quiver3(pos_norm(:,1),pos_norm(:,2),pos_norm(:,3),...
%                     vect_norm(:,1),vect_norm(:,2),vect_norm(:,3),1,'k');
%                 set(hq,'Color',.5.*[1 1 1])
                
%                 % Highlight closest normal vector
%                 quiver3(pos_norm(i_norm,1),pos_norm(i_norm,2),pos_norm(i_norm,3),...
%                     vect_norm(i_norm,1),vect_norm(i_norm,2),vect_norm(i_norm,3),.2,'k');
                %quiver3
                
                % Plot prey direction
                quiver3(prey_pos(j,1),prey_pos(j,2),prey_pos(j,3),...
                        prey_dir(j,1),prey_dir(j,2),prey_dir(j,3),1,'r')
                      
                
                clear p
            end
            
            % Clear variables
            clear spd_prey faces verts pos_norm vect_nor dist i_norm th_pred
            clear phi_pred r_pred th_meas phi_meas r_meas
            
        end
        
        if vis_seqs
            title([num2str(spds(i)) ' cm/s'])
            xlabel('x')
            ylabel('y')
            zlabel('z')
            %view(2)
            view([0 180])
        end
        
        
        % Clear for next speed
        clear cR prey_dir prey_pos lat_offset idx prey_dir
        
        disp(' ');disp(['Done ' num2str(spds(i)) ' cm/s'])
        
    end % Loop for each speed
    
    % Save cue analysis data
    save([root_path filesep 'flow cue analysis'],'r')
 
else
    % Load previous 'r' 
    load([root_path filesep 'flow cue analysis'])
    
end % do_direction




if vis_directcue


figure;

% Plot results
subplot(2,2,1)


inc{1} = index{1} & ~r.vent & ~r.wrong;
inc{2} = index{2} & ~r.vent & ~r.wrong;
inc{3} = index{3} & ~r.vent & ~r.wrong;


scatter_plot(r.th_pred,r.th_meas,inc)

xlabel('az of velocity at COM (dorsal)')
ylabel('az of response ')

subplot(2,2,2)

inc{1} = index{1} & r.vent & ~r.wrong;
inc{2} = index{2} & r.vent & ~r.wrong;
inc{3} = index{3} & r.vent & ~r.wrong;

scatter_plot(r.th_pred,r.th_meas,inc)

xlabel('az of velocity at COM (ventral)')
ylabel('az of response ')


subplot(2,2,3)

inc{1} = index{1} & ~r.vent;
inc{2} = index{2} & ~r.vent;
inc{3} = index{3} & ~r.vent;

scatter_plot(r.phi_pred,r.phi_meas,inc)

xlabel('el of velocity at COM (dorsal)')
ylabel('el of response')


subplot(2,2,4)

inc{1} = index{1} & r.vent;
inc{2} = index{2} & r.vent;
inc{3} = index{3} & r.vent;

scatter_plot(r.phi_pred,r.phi_meas,inc)

xlabel('el of velocity at COM (ventral)')
ylabel('el of response')



return

 
subplot(2,2,2)
pred = [min(r.phi_pred) max(r.phi_pred)];

preds = [r.phi_pred(index{1}); r.phi_pred(index{2}); r.phi_pred(index{3})];
meas  = [r.phi_meas(index{1}); r.phi_meas(index{2}); r.phi_meas(index{3})];

[c,cint,res,resint,stats]=regress(meas,[ones(length(preds),1) preds]);

plot(r.phi_pred(index{1}),r.phi_meas(index{1}),'ro',...
     r.phi_pred(index{2}),r.phi_meas(index{2}),'bo',...
     r.phi_pred(index{3}),r.phi_meas(index{3}),'go',...
     [pred(1) pred(2)],[pred(1) pred(2)],'k-',...
     [pred(1) pred(2)],c(2).*[pred(1) pred(2)]+c(1),'k--');

title(['Elevation, r2=' num2str(stats(1)) ' p=' num2str(stats(3))]) 
axis square


end


function scatter_plot(pred,meas,index)

% All predicted values
p_pool = [pred(index{1}) ; ...
          pred(index{2}) ;...
          pred(index{3}) ];
     
% Range of predicted values
pred_range = [min(p_pool) max(p_pool)];

% All measurements
m_pool = [meas(index{1}); ...
          meas(index{2}); ...
          meas(index{3})];

% Run regression on all data together
[c,cint,res,resint,stats] = regress(m_pool,[ones(length(p_pool),1) p_pool]);

plot(pred(index{1}),meas(index{1}),'ro',...
     pred(index{2}),meas(index{2}),'bo',...
     pred(index{3}),meas(index{3}),'go',...
     [pred_range(1) pred_range(2)],c(2).*[pred_range(1) pred_range(2)]+c(1),'k--');
 
 %[pred_range(1) pred_range(2)],[pred_range(1) pred_range(2)],'k-',...
 
title(['r2=' num2str(stats(1)) ' p=' num2str(stats(3))]) 
axis square
legend('2','11','20','Location','NorthWest') 






function plot_prey_pos(f,spd_index)


idx = find(spd_index);
for i = 1:length(idx)
    plot3([f.xbod(idx(i),1) f.xbod(idx(i),end)],...
          [f.ybod(idx(i),1) f.ybod(idx(i),end)],...
          [f.zbod(idx(i),1) f.zbod(idx(i),end)],'-k',...
           f.xbod(idx(i),1),f.ybod(idx(i),1),f.zbod(idx(i),1),'ok');
    hold on
end
axis equal
xlims = xlim;

plot3([xlims(1) 0],[0 0],[0 0],'r-',0,0,0,'or')

grid on
hold off

xlabel('x')
ylabel('y')
zlabel('z')

view([0 90])


function [pos,vect_norm] = cal_norms(faces,verts)
% Finds the postion and direction of vectors normal to a 3D surface

% First vectors directed between verticies
vect1 = verts(faces(:,2),:)-verts(faces(:,1),:);

% Second vectors between verticies
vect2 = verts(faces(:,3),:)-verts(faces(:,1),:);

% Normal vectors
vect_norm = cross(vect2,vect1,2);

% Magnitude of normal vectors
norm_mag = sqrt(vect_norm(:,1).^2 + vect_norm(:,2).^2 + vect_norm(:,3).^2);

%Normalize the normal vectors
vect_norm = [vect_norm(:,1)./norm_mag ...
    vect_norm(:,2)./norm_mag ...
    vect_norm(:,3)./norm_mag];

% Position of normal vectors (centered btwn verticies)
pos(:,1) = mean([verts(faces(:,1),1) ...
    verts(faces(:,2),1) ...
    verts(faces(:,3),1)],2);
pos(:,2) = mean([verts(faces(:,1),2) ...
    verts(faces(:,2),2) ...
    verts(faces(:,3),2)],2);
pos(:,3) = mean([verts(faces(:,1),3) ...
    verts(faces(:,2),3) ...
    verts(faces(:,3),3)],2);


