function ana_all(root_path)
% Performs analyses on the data in 'flow_along_body.mat', which is
% generated by ana_body_flow.m



%% Code execution

% Create boxplots of each parameter that could serve as a cue
do_boxplots = 0;

% Plots 3D volumes of flow field and responses
do_3D = 0;

% Compares the direction of flow gradient to direction of behavior
do_directioncue = 0;

% Visualize results of direction cue 
% (visualizes results of do_directioncue)
vis_directcue = 0;

% Descriptive stats of directional response
do_direction = 0;

% Directional responses wrt differences in flow along body
do_bodycue = 0;

% Make rose plots of response direction wrt the body for categories of
% differences in flow (results of do_bodycue)
vis_rose_local = 0;

% Make rose plots of response direction wrt the global FOR
vis_rose_global = 0;

% Visualize individual sequences
vis_seqs = 0;

% Visualze flow wrt body of the larvae
do_localflow = 0;

% Visualze flow wrt body of the larvae 2D
do_localflow2D = 1;

% Visualize position of responses from above and side for all three speeds
do_position = 0;


%% Parameters

% Period between detection and fast start initiation (s)
latency = 5e-3;

% Modeled threshold of shearing for a response
sh_thresh = .5;

% Modeled threshold of speed
spd_thresh = .1;

% Relative position of COM along length of the body (this is Matt's guess)
COM_pos = .25;

% Alpha transparency for the isosurface plots
alpha_val = .4;

% Inerval for skipping plotting of normal vectors
norm_skip = 100;

% Scaling of body length for CFD volume examine for isosurface
sclfactr = .25;

% Scaling of body length for CFD volume around whole body
%sclfactr_bod = 1.1;
sclfactr_bod = 1.5;

% Number of bins used in rose plots
num_bin = 20;

% Dividing line for lateral/medial position (cm)
lat_pos = 0.5;

% Number of points around the periphery of the prey body
numPts_circ = 50;

preyColor = [.5 .5 .5];


%% Paths

if nargin < 1
    root_path = uigetdir(pwd,'Select root directory (holds "cfd" & "behavior")');
end

% Paths to CFD data arranged in regular grid
cfd_path{1}  = [root_path filesep 'cfd' filesep 'flow_02cmps_reggrid.mat'];
cfd_path{2}  = [root_path filesep 'cfd' filesep 'flow_11cmps_reggrid.mat'];
cfd_path{3}  = [root_path filesep 'cfd' filesep 'flow_20cmps_reggrid.mat'];


%% Load data & define variables

% Load flow data long body ('f')
load([root_path filesep 'behavior' filesep 'flow_along_body.mat'])

% Load behavior data ('b')
load([root_path filesep 'behavior' filesep 'Transformed_Prey_Coords.mat'])

% Number of sequences
num_seq = length(b.preyx(:,1));

% Values of speeds
spds = [2 11 20];

% Indices for each speed of sequences in the dark, with lateral line intact
index{1} = (b.speed(1:num_seq)==2) & (b.LL(1:num_seq)==1) ...
     & ~isnan(b.preyx(:,1)) & (b.lit(1:num_seq)==0);

index{2} = (b.speed(1:num_seq)==11) & (b.LL(1:num_seq)==1) ...
     & ~isnan(b.preyx(:,1)) & (b.lit(1:num_seq)==0);
 
index{3} = (b.speed(1:num_seq)==20) & (b.LL(1:num_seq)==1) ...
     & ~isnan(b.preyx(:,1)) & (b.lit(1:num_seq)==0);

% Create groups by speed
groups = [b.speed(index{1}); b.speed(index{2}); b.speed(index{3})];


%% Response boxplots (do_boxplots)

if do_boxplots
    
%     % Distance of each of the three body points
%     dist1 = sqrt( b.preyx(:,1).^2 + b.preyy(:,1).^2 + b.preyz(:,1).^2 );
%     dist2 = sqrt( b.preyx(:,2).^2 + b.preyy(:,2).^2 + b.preyz(:,2).^2 );
%     dist3 = sqrt( b.preyx(:,3).^2 + b.preyy(:,3).^2 + b.preyz(:,3).^2 );
%     
%     % Use minimum distance as the response distance
%     resp_dist = min([dist1 dist2 dist3],[],2);
    
    % Max speed along body for each speed
    max_bod_spd =  [max(f.spd(index{1},:),[],2); ...
        max(f.spd(index{2},:),[],2); ...
        max(f.spd(index{3},:),[],2)];
    
    % Max velocity gradient along body for each speed
    max_velgrad =  [max(abs(f.velgrad(index{1},:)),[],2); ...
        max(abs(f.velgrad(index{2},:)),[],2); ...
        max(abs(f.velgrad(index{3},:)),[],2)];
    
    % Max shearing along body for each speed
    max_shear   =  [max(f.shrdef(index{1},:),[],2); ...
        max(f.shrdef(index{2},:),[],2); ...
        max(f.shrdef(index{3},:),[],2)];
    
    % Boxplots
    figure;
    
    subplot(2,2,1)
    boxplot(max_bod_spd, groups)
    xlabel('speed (cm/s)')
    ylabel('max speed along body')
    
    subplot(2,2,2)
    boxplot(max_velgrad, groups)
    xlabel('speed (cm/s)')
    ylabel('max vel gradient along body')
    
    subplot(2,2,3)
    boxplot(max_shear, groups)
    xlabel('speed (cm/s)')
    ylabel('max shear deformation along body')  
    
    clear dist1 dist2 dist3 resp_dist max_bod_spd max_velgrad max_shear
end


%% Plot 3D spatial distibution of responders (do_3D)

if do_3D  
    
    % Color of predator
    p_clr = .6.*[1 1 1];
    
    % Color of surface
    s_clr = [102 102 255]./255;
    
    % Color of correct direction
    c_clr = [0 127 0]./255;
    
    % Color of wrong direction
    w_clr = [255 0 0]./255;
    
    % Load predator data
    load([root_path filesep 'morphology' filesep 'Pred3Dbodyshape.mat']) 
    
    
    % Step through each speed
    for i = 2 %1:3
        
        % New Figure window
        figure 
        
        % Load CFD data in 'cR' strcuture
        load(cfd_path{i})
        
        
        % Choose index for sequences that have stage 2 data
        idx = index{i} & ~isnan(b.preyx2(:,2)) & b.preyx(:,1)>0  ...
              & b.preyx(:,2)>0  & b.preyx(:,3)>0;
        
        % Get body points for all seqnences in current speed
        [rost0,com0,tail0,rost1,com1,tail1,rost2,com2,tail2,i_vent,...
            i_wrong,prey_dir] = give_points(b,idx,latency,spds(i));
        
        
        % 3D plot of speed and resposes -----------------------------------
        
        % Plot of position at response
        %subplot(1,2,1)
        
        for j = 1:size(rost1,1)
            % Plot location of larvae
            h = plot3([rost1(j,1) tail1(j,1)], ...
                [rost1(j,2) tail1(j,2)], ...
                [rost1(j,3) tail1(j,3)],'k',...
                rost1(j,1),rost1(j,2),rost1(j,3),'ok');
            hold on
            warning off
            if i_wrong(j)
                arrow3(com1(j,:),com2(j,:),'r-1',3,3);
            else
                arrow3(com1(j,:),com2(j,:),'e-1',3,3);
                %arrow3('colors',0.5) 
            end
            warning on
            axis equal
            
            % Remove location of larvae
            delete(h)
        end
%         plot_prey_pos(f,index{i})
         hold on
        %title(['Speed (' num2str(spds(i)) ' cm/s)'])
        xlims = xlim;
        ylims = ylim;
        zlims = zlim;
        
        
%         p_idx = pred3DshapeX>min(xlims) & pred3DshapeX<max(xlims) & ...
%                 pred3DshapeY>min(ylims) & pred3DshapeY<max(ylims) & ...
%                 pred3DshapeZ>min(zlims) & pred3DshapeZ<max(zlims);
        
        % Render the predator body
        h1 = patch(real(pred3DshapeX),real(pred3DshapeY),...
               real(pred3DshapeZ),real(pred3DshapeX)*0);
        
        set(h1,'FaceLighting','gouraud',...
               'LineStyle','none',...
               'BackFaceLighting','reverselit',...
               'FaceColor',p_clr,...
               'AmbientStrength',.5);
    
        
        % Isosurface
        [faces,verts] = isosurface(cR.x,cR.y,cR.z,smooth3(cR.spd),spd_thresh);
        p = patch('Vertices', verts, 'Faces', faces, ...
                  'FaceColor','interp', ...
                  'edgecolor', 'interp');
        set(p,'FaceColor',s_clr,'EdgeColor','none');
        daspect([1,1,1])
        %view(3);
        axis tight
        %camlight
        lighting gouraud
        alpha(p,alpha_val)
        xlims = xlim;
        ylims = ylim;
        zlims = zlim;
        %xlabel('x'),ylabel('y'),zlabel('z')
        
        %view([39 36])
        %view([0 90])
        view([56 4])
        light('position',[60,60,0])
        %light('position',[0,-60,60])
        light('position',[0,-60,-30])
        %xlim([-1 1.5])
        
        % This is supposed to smooth the surface plot
        %isonormals(cR.x,cR.y,cR.z,cR.spd,p);       
        
        hold off
        
%         % 3D plot of shearing and resposes --------------------------------
%         
%         % Plot of position at response
%         subplot(1,2,2)
%         %plot_prey_pos(b,index{i})
%         for j = 1:size(rost1,1)
%             plot3([rost1(j,1) tail1(j,1)], ...
%                   [rost1(j,2) tail1(j,2)], ...
%                   [rost1(j,3) tail1(j,3)],'k',...
%                   rost1(j,1),rost1(j,2),rost1(j,3),'ok')
%             arrow3(com1(j,:),com2(j,:),'k')
%         end
%         
%         hold on
%         title(['Shear deformation (' num2str(spds(i)) ' cm/s)'])
%         xlims = xlim;
%         ylims = ylim;
%         zlims = zlim; 
%         
%         hold on
%         
%         % Isosurface
%         p = patch(isosurface(cR.x,cR.y,cR.z,smooth3(cR.sh_def),sh_thresh));
%         isonormals(cR.x,cR.y,cR.z,cR.sh_def,p)
%         set(p,'FaceColor','red','EdgeColor','none');
%         daspect([1,1,1])
%         %view(3);
%         axis tight
%         camlight
%         lighting gouraud
%         alpha(p,alpha_val)
%         
%         hold off
        
    end   
    
    set(gca,'XColor','w')
    set(gca,'YColor','w')
    set(gca,'ZColor','w')
    zoom(1.75)
    
end


%% Description of directional response (do_direction)

if do_direction
    
    % Initialize result vectors
    r.pred_spd = nan(size(b.preyx(:,1),1),1);
    r.th_pred  = nan(size(b.preyx(:,1),1),1);
    r.phi_pred = nan(size(b.preyx(:,1),1),1);
    r.th_meas  = nan(size(b.preyx(:,1),1),1);
    r.phi_meas = nan(size(b.preyx(:,1),1),1);
    r.az_prey  = nan(size(b.preyx(:,1),1),1);
    r.el_prey  = nan(size(b.preyx(:,1),1),1);
    
    for i = 1:3
        
        % Choose index for sequences that have stage 2 data
        idx = index{i} & ~isnan(b.preyx2(:,2)) & b.preyx(:,1)>0  ...
              & b.preyx(:,2)>0  & b.preyx(:,3)>0;
          
        % Get body points for all seqnences in current speed
        [rost0,com0,tail0,rost1,com1,tail1,rost2,com2,tail2,i_vent,...
            i_wrong,prey_dir] = give_points(b,idx,latency,spds(i));
        
        % Spherical coordinates for prey position
        [prey_az,prey_el,prey_r] = cart2sph(com0(:,1),com0(:,2),com0(:,3));
                                        
        % Spherical coordinates for prey direction                                
        [dir_az,dir_el,dir_r] = cart2sph(prey_dir(:,1),prey_dir(:,2),...
                                         prey_dir(:,3));
         
        disp(['Spd = ' num2str(spds(i)) '  ' ...
              num2str(100*sum(~i_wrong)/length(i_wrong)) '% '])
    
%         % Orientation of prey wrt predator on XY plane
%         prey_orient = atan2(prey_pos(:,2)-rost_pos(:,2),...
%                             prey_pos(:,1)-rost_pos(:,1));
                                        
        % Index of indivudual positioned ventral to predator
        i_vent = com0(:,3)<=0;        
        
        % Index of D-V responses in the 'wrong' direction
        i_wrong = (i_vent & (prey_dir(:,3)>0)) |  ...
                    (~i_vent & (prey_dir(:,3)<=0));
        
                
        
    
        if 1
            figure
            subplot(2,3,1)
            
            arrow3(com1(~i_wrong,:),com2(~i_wrong,:),'g')
            hold on
            arrow3(com1(i_wrong,:),com2(i_wrong,:),'r')
            hold off
            
            title([num2str(spds(i)) ' cm/s'])
            xlabel('x');ylabel('y');zlabel('z')
            axis equal
            view([0 90])
            
            light('position',[10 10 10],'style','local')
            light('position',[-60,-60,-60]), lighting gouraud
            
            subplot(2,3,2)
            rose(dir_az(~i_vent & ~i_wrong),num_bin)
            hold on
            hR = rose(dir_az(~i_vent & i_wrong),num_bin);
            set(hR,'Color','r')
            hold off
            title('direction azimuth (dorsal)')
            
            subplot(2,3,3)
            rose(dir_az(i_vent & ~i_wrong),num_bin)
            hold on
            hR = rose(dir_az(i_vent & i_wrong),num_bin);
            set(hR,'Color','r')
            title('direction azimuth (ventral)')
            
            subplot(2,3,4)
            arrow3(com1(~i_wrong,:),com2(~i_wrong,:),'b')
            hold on
            arrow3(com1(i_wrong,:),com2(i_wrong,:),'r')
            hold off
            
            title([num2str(spds(i)) ' cm/s'])
            xlabel('x');ylabel('y');zlabel('z')
            axis equal
            view([0 180])
            
            light('position',[10 10 10],'style','local')
            light('position',[-60,-60,-60]), lighting gouraud
            
            subplot(2,3,5)
            rose(dir_el(~i_vent & ~i_wrong),num_bin)
            hold on
            hR = rose(dir_el(~i_vent & i_wrong),num_bin);
            set(hR,'Color','r')
            hold off
            
            title('direction elevation (dorsal)')
            
            subplot(2,3,6)
            rose(dir_el(i_vent & ~i_wrong),num_bin)
            hold on
            hR = rose(dir_el(i_vent & i_wrong),num_bin);
            set(hR,'Color','r')
            hold off
            title('direction elevation (ventral)')
            
%             figure
%             plot(prey_orient(~i_wrong),'bo')
%             hold on
%             plot(prey_orient(i_wrong),'ro')
%             title([num2str(spds(i)) ' cm/s'])
%             hold off
        end
        
        clear prey_dir prey_pos lat_offset idx 
    end

end % do_direction


%% Analyze flow cues that predict direction of response (do_directioncue)

if do_directioncue
    
    % Initialize result vectors
    r.pred_spd = nan(size(b.preyx(:,1),1),1);
    r.th_pred  = nan(size(b.preyx(:,1),1),1);
    r.phi_pred = nan(size(b.preyx(:,1),1),1);
    r.th_meas  = nan(size(b.preyx(:,1),1),1);
    r.phi_meas = nan(size(b.preyx(:,1),1),1);
    r.az_prey  = nan(size(b.preyx(:,1),1),1);
    r.el_prey  = nan(size(b.preyx(:,1),1),1);
    r.wrong    = zeros(size(b.preyx(:,1),1),1);
    r.vent     = zeros(size(b.preyx(:,1),1),1);
    
    % Loop through speeds
    for i = 1:3
        
        if vis_seqs
            figure;
        end
        
        % Choose index for sequences that have stage 2 data
        idx = index{i} & ~isnan(b.preyx2(:,2)) & b.preyx(:,1)>0  ...
              & b.preyx(:,2)>0  & b.preyx(:,3)>0;
        
        % Sequence numbers 
        seqs = find(idx);
        
        % Offset in x, due to latency
        lat_offset = latency * spds(i);
        
        % Load CFD data in 'cR' structure
        load(cfd_path{i})
        
        % Find position of prey
        prey_pos = [b.preyx(idx,2)+lat_offset b.preyy(idx,2) b.preyz(idx,2)];
        
        % Find direction of prey
        prey_dir(:,1) = b.preyx2(idx,2) - b.preyx(idx,2);
        prey_dir(:,2) = b.preyy2(idx,2) - b.preyy(idx,2);
        prey_dir(:,3) = b.preyz2(idx,2) - b.preyz(idx,2);
        
%         % Transform prey position, assuming mirror symmetry about the predator
%         prey_dir(prey_pos(:,2)<0,2) = -prey_dir(prey_pos(:,2)<0,2);  
%         prey_pos(:,2)     = abs(prey_pos(:,2));
        
        % Index of indivudual positioned ventral to predator
        i_vent = prey_pos(:,3)<=0;
        
        % Index of L-R responses in the 'wrong' direction
        i_wrong = prey_dir(:,2)<0;
        
        % Step thru each sequence for current speed
        for j = 1:length(seqs)
            
            % Body length of prey
            blength = norm([b.preyx(seqs(j),3)-b.preyx(seqs(j),1) ...
                            b.preyy(seqs(j),3)-b.preyy(seqs(j),1) ...
                            b.preyz(seqs(j),3)-b.preyz(seqs(j),1)]);
           
            % Range of volume to interrogate
            rangeX   = [prey_pos(j,1)-blength*sclfactr ...
                        prey_pos(j,1)+blength*sclfactr];
            rangeY   = [prey_pos(j,2)-blength*sclfactr ...
                        prey_pos(j,2)+blength*sclfactr];
            rangeZ   = [prey_pos(j,3)-blength*sclfactr ...
                        prey_pos(j,3)+blength*sclfactr];
            subRange = [rangeX(1) rangeX(2) ...
                        rangeY(1) rangeY(2) ...
                        rangeZ(1) rangeZ(2)];
            
            % Reduce flow field to small volume
            [xS,yS,zS,spdS] = subvolume(cR.x,cR.y,cR.z,cR.spd,subRange);
            [xS,yS,zS,uS] = subvolume(cR.x,cR.y,cR.z,cR.u,subRange);
            [xS,yS,zS,vS] = subvolume(cR.x,cR.y,cR.z,cR.v,subRange);
            [xS,yS,zS,wS] = subvolume(cR.x,cR.y,cR.z,cR.w,subRange);
            [xS,yS,zS,xCS] = subvolume(cR.x,cR.y,cR.z,cR.xCurl,subRange);
            [xS,yS,zS,yCS] = subvolume(cR.x,cR.y,cR.z,cR.yCurl,subRange);
            [xS,yS,zS,zCS] = subvolume(cR.x,cR.y,cR.z,cR.zCurl,subRange);
            clear blength rangeX rangeY rangeZ subRange
            
            % Speed at the prey COM
            spd_prey = griddata(xS,yS,zS,spdS,prey_pos(j,1),prey_pos(j,2),prey_pos(j,3));
            
            % Velocity at the prey COM
            u_prey = griddata(xS,yS,zS,uS,prey_pos(j,1),prey_pos(j,2),prey_pos(j,3));
            v_prey = griddata(xS,yS,zS,vS,prey_pos(j,1),prey_pos(j,2),prey_pos(j,3));
            w_prey = griddata(xS,yS,zS,wS,prey_pos(j,1),prey_pos(j,2),prey_pos(j,3));
            
            % Curl at prey COM
            %xC_prey = griddata(xS,yS,zS,xCS,prey_pos(j,1),prey_pos(j,2),prey_pos(j,3));
            %yC_prey = griddata(xS,yS,zS,yCS,prey_pos(j,1),prey_pos(j,2),prey_pos(j,3));
            %zC_prey = griddata(xS,yS,zS,zCS,prey_pos(j,1),prey_pos(j,2),prey_pos(j,3));
            
            % Isosurface in this small volume
            [faces,verts] = isosurface(xS,yS,zS,spdS,spd_prey);
            
            % Calculate normal vectors
            %[pos_norm,vect_norm] = cal_norms(faces,verts);
            
            % Distance between verticies and prey COM
%             dist = sqrt((pos_norm(:,1)-prey_pos(j,1)).^2 +  ...
%                         (pos_norm(:,2)-prey_pos(j,2)).^2 + ...
%                         (pos_norm(:,3)-prey_pos(j,3)).^2);
%                     
%             % Index for normal vector closest to the COM
%             i_norm = find(dist==min(dist));
            
            % Find index for flow data at COM
            %distCOM = abs(f.s(seqs(j),:)./max(f.s(seqs(j),:)) - COM_pos);
            %iCOM = find(distCOM == min(distCOM));
            
            
%              % Flow predicted diretcion, based on velocity and curl
%              tmp = cross([xC_prey,yC_prey,zC_prey],[u_prey,v_prey,w_prey]);
%              tmp = tmp./norm(tmp);
%              xPredict = tmp(1);yPredict = tmp(2);zPredict = tmp(3);
%             [th_pred,phi_pred,r_pred] = cart2sph(tmp(1),...
%                                                  tmp(2),...
%                                                  tmp(3));
            
            % Flow velocity at COM
            [th_pred,phi_pred,r_pred] = cart2sph(u_prey,...
                                                 v_prey,...
                                                 w_prey);
            % Calculate angles of predicted vector
%             [th_pred,phi_pred,r_pred] = cart2sph(vect_norm(i_norm,1),...
%                                                  vect_norm(i_norm,2),...
%                                                  vect_norm(i_norm,3));
            
            % Calculate angles of measured direction vector
            [th_meas,phi_meas,r_meas] = cart2sph(prey_dir(j,1),...
                                                 prey_dir(j,2),...
                                                 prey_dir(j,3));   
            % Calcuate angles of prey position
            [az_prey,el_prey,r_prey] = cart2sph(prey_pos(j,1),...
                                                prey_pos(j,2),...
                                                prey_pos(j,3));
            
            % Store result
            r.pred_spd(seqs(j)) = spds(i);                                
%             r.th_pred(seqs(j))  = th_pred *180/pi;
%             r.phi_pred(seqs(j)) = phi_pred*180/pi;
            r.th_meas(seqs(j))  = th_meas*180/pi;
            r.phi_meas(seqs(j)) = phi_meas*180/pi;
            r.az_prey(seqs(j))  = az_prey*180/pi;
            r.el_prey(seqs(j))  = el_prey*180/pi;
            r.th_pred(seqs(j))  = th_pred *180/pi;
            r.phi_pred(seqs(j)) = phi_pred *180/pi;
            r.wrong(seqs(j))    = i_wrong(j);
            r.vent(seqs(j))     = i_vent(j);
            
            
            % Visulaize this step (to confirm calculations
            if vis_seqs
                % Isosurface of speed
                p = patch('Vertices', verts, 'Faces', faces, ...
                    'FaceColor','interp', ...
                    'edgecolor', 'interp');
                set(p,'FaceColor','red','EdgeColor','none');
                daspect([1,1,1])
                %view(3);
                axis tight
                camlight
                lighting gouraud
                alpha(p,alpha_val)
                hold on
                
%                 quiver3(prey_pos(j,1),prey_pos(j,2),prey_pos(j,3),...
%                         xPredict,yPredict,zPredict,0.3,'b')
                
%                 % Normal vectors
%                 hq = quiver3(pos_norm(:,1),pos_norm(:,2),pos_norm(:,3),...
%                     vect_norm(:,1),vect_norm(:,2),vect_norm(:,3),1,'k');
%                 set(hq,'Color',.5.*[1 1 1])
                
%                 % Highlight closest normal vector
%                 quiver3(pos_norm(i_norm,1),pos_norm(i_norm,2),pos_norm(i_norm,3),...
%                     vect_norm(i_norm,1),vect_norm(i_norm,2),vect_norm(i_norm,3),.2,'k');
                %quiver3
                
                % Plot prey direction
                quiver3(prey_pos(j,1),prey_pos(j,2),prey_pos(j,3),...
                        prey_dir(j,1),prey_dir(j,2),prey_dir(j,3),1,'r')
                      
                
                clear p
            end
            
            % Clear variables
            clear spd_prey faces verts pos_norm vect_nor dist i_norm th_pred
            clear phi_pred r_pred th_meas phi_meas r_meas
            
        end
        
        if vis_seqs
            title([num2str(spds(i)) ' cm/s'])
            xlabel('x')
            ylabel('y')
            zlabel('z')
            %view(2)
            view([0 180])
        end
        
        
        % Clear for next speed
        clear cR prey_dir prey_pos lat_offset idx prey_dir
        
        disp(' ');disp(['Done ' num2str(spds(i)) ' cm/s'])
        
    end % Loop for each speed
    
    % Save cue analysis data
    save([root_path filesep 'flow cue analysis'],'r')
 
else
    % Load previous 'r' 
    load([root_path filesep 'flow cue analysis'])
    
end % do_direction


%% Visualize direction cue results (vis_directcue)

if vis_directcue
    
    
    figure;
    
    % Plot results
    subplot(2,2,1)
    
    
    inc{1} = index{1} & ~r.vent & ~r.wrong;
    inc{2} = index{2} & ~r.vent & ~r.wrong;
    inc{3} = index{3} & ~r.vent & ~r.wrong;
    
    
    scatter_plot(r.th_pred,r.th_meas,inc)
    
    xlabel('az of velocity at COM (dorsal)')
    ylabel('az of response ')
    
    subplot(2,2,2)
    
    inc{1} = index{1} & r.vent & ~r.wrong;
    inc{2} = index{2} & r.vent & ~r.wrong;
    inc{3} = index{3} & r.vent & ~r.wrong;
    
    scatter_plot(r.th_pred,r.th_meas,inc)
    
    xlabel('az of velocity at COM (ventral)')
    ylabel('az of response ')
    
    
    subplot(2,2,3)
    
    inc{1} = index{1} & ~r.vent;
    inc{2} = index{2} & ~r.vent;
    inc{3} = index{3} & ~r.vent;
    
    scatter_plot(r.phi_pred,r.phi_meas,inc)
    
    xlabel('el of velocity at COM (dorsal)')
    ylabel('el of response')
    
    
    subplot(2,2,4)
    
    inc{1} = index{1} & r.vent;
    inc{2} = index{2} & r.vent;
    inc{3} = index{3} & r.vent;
    
    scatter_plot(r.phi_pred,r.phi_meas,inc)
    
    xlabel('el of velocity at COM (ventral)')
    ylabel('el of response')
    
end


%% Analyze direction wrt flow differences along the body (do_bodycue)

if do_bodycue
    
    % Series of points to evaluate flow along the body (body lengths)
    s = linspace(0,1,20)';
    
    nan1  = nan(size(b.preyx(:,1),1),1);
    nan3  = nan(size(b.preyx(:,1),1),3);
    cell1 = cell(size(b.preyx(:,1),1),1);
    zero1 = zeros(size(b.preyx(:,1),1),1);
    
    % Initialize result vectors
    r.pred_spd  = nan1;
    r.spd_rost  = nan1;
    r.spd_tail  = nan1;
    r.spd_right = cell1;
    r.spd_left  = cell1;
    r.spd_dors  = cell1;
    r.spd_vent  = cell1;
    r.az_dir    = nan1;
    r.el_dir    = nan1;
    r.wrongLR   = zero1;
    r.wrongDV   = zero1;
    r.vent      = zero1;
    
    clear nan1 nan3 cell1
    
    if vis_seqs
        figure;
    end
    
    % Loop through speeds
    for i = 1:3
        
        if vis_seqs
            figure;
        end
        
        % Load CFD data in 'cR' structure
        load(cfd_path{i})
        
        % Choose index for sequences that have stage 2 data
        idx = index{i} & ~isnan(b.preyx2(:,2)) & b.preyx(:,1)>0  ...
              & b.preyx(:,2)>0  & b.preyx(:,3)>0;
        
        % Sequence numbers 
        seqs = find(idx);
        
        % Get body points for all sequences in current speed
        [rost0,com0,tail0,rost1,com1,tail1,rost2,com2,tail2,i_vent,...
         i_wrong,prey_dir] = give_points(b,idx,latency,spds(i));
        
        % Index of individuals positioned ventral to predator
        i_vent = com0(:,3)<=0;
        
        % Index of all wrong directions based on distance from axis 
        % extending from predator midline (Bill)
        
        %calculate dist from mildline at t1 and t2
        dist1 = (com1(:,2).^2 + com1(:,3).^2).^0.5;
        dist2 = (com2(:,2).^2 + com2(:,3).^2).^0.5;
        
        %those going in wrong direction have smaller d2 
        i_wrong = dist2 < dist1;
       
        % Step thru each sequence for current speed
        for j = 1:length(seqs)

            % Body length of prey
            blength = norm([tail0(j,1)-rost0(j,1) ...
                            tail0(j,2)-rost0(j,2) ...
                            tail0(j,3)-rost0(j,3)]);       
                        
            % Range of volume to interrogate
            rangeX   = [com0(j,1)-blength*sclfactr_bod ...
                        com0(j,1)+blength*sclfactr_bod];
            rangeY   = [com0(j,2)-blength*sclfactr_bod ...
                        com0(j,2)+blength*sclfactr_bod];
            rangeZ   = [com0(j,3)-blength*sclfactr_bod ...
                        com0(j,3)+blength*sclfactr_bod];
            subRange = [rangeX(1) rangeX(2) ...
                        rangeY(1) rangeY(2) ...
                        rangeZ(1) rangeZ(2)];
            
            % Reduce flow field to small volume
            [xS,yS,zS,spdS] = subvolume(cR.x,cR.y,cR.z,cR.spd,subRange);
            %[xS,yS,zS,uS] = subvolume(cR.x,cR.y,cR.z,cR.u,subRange);
            %[xS,yS,zS,vS] = subvolume(cR.x,cR.y,cR.z,cR.v,subRange);
            %[xS,yS,zS,wS] = subvolume(cR.x,cR.y,cR.z,cR.w,subRange);

            clear rangeX rangeY rangeZ subRange

            % Points on the L and R of the body
            tmp = ones(length(s),1);
            l_ptL = [s.*blength tmp.*(-blength/10) 0.*tmp];
            r_ptL = [s.*blength tmp.*(blength/10) 0.*tmp];
            d_ptL = [s.*blength 0.*tmp tmp.*(blength/10)];
            v_ptL = [s.*blength 0.*tmp tmp.*(-blength/10)];
            clear tmp
            
%             l_ptL = [blength/2 -blength/10 0];
%             r_ptL = [blength/2  blength/10 0];
%             d_ptL = [blength/2  0 blength/10];
%             v_ptL = [blength/2  0 -blength/10];
            
            % L and R points transformed into global cooridnate system
            l_pt = local_to_global(rost0(j,:),com0(j,:),tail0(j,:),l_ptL);
            r_pt = local_to_global(rost0(j,:),com0(j,:),tail0(j,:),r_ptL);
            d_pt = local_to_global(rost0(j,:),com0(j,:),tail0(j,:),d_ptL);
            v_pt = local_to_global(rost0(j,:),com0(j,:),tail0(j,:),v_ptL);
            
%             sqrt((com1(j,1)-com2(j,1))^2 + (com1(j,2)-com2(j,2))^2 + ...
%                  (com1(j,3)-com2(j,3))^2)
            
            % Package points for griddata
            pnts = [l_pt; r_pt; rost0(j,:); tail0(j,:); d_pt; v_pt];
            
            % Interpolate for speed 
            spd_vals = griddata(xS,yS,zS,spdS,pnts(:,1),pnts(:,2),pnts(:,3));

            % Speed values at different spots on the body
            spd_left  = spd_vals(1:length(l_pt));
            spd_right = spd_vals((length(l_pt)+1):(length(l_pt)+length(r_pt)));  
            spd_rost  = spd_vals((length(l_pt)+1+length(r_pt)));
            spd_tail  = spd_vals(((length(l_pt)+1+length(r_pt))+1));
            spd_dors  = spd_vals(((length(l_pt)+3+length(r_pt))):...
                                 ((length(l_pt)+2+length(r_pt))+length(d_pt)));
            spd_vent  = spd_vals(((length(l_pt)+3+length(r_pt))+length(d_pt):...
                                 ((length(l_pt)+2+length(r_pt))+length(d_pt)+length(v_pt))));
            clear spd_vals pnts

            % Transform position wrt prey body at time 1
            com2L = global_to_local(rost1(j,:),com1(j,:),tail1(j,:),com2(j,:));
            com1L = global_to_local(rost1(j,:),com1(j,:),tail1(j,:),com1(j,:));
            
            % Calculate response direction from local FOR at time 1
            prey_dirL(:,1) = com2L(:,1) - com1L(:,1);
            prey_dirL(:,2) = com2L(:,2) - com1L(:,2);
            prey_dirL(:,3) = com2L(:,3) - com1L(:,3);
            
            % Angle of response wrt body
            [az_dir,el_dir,r_dir] = cart2sph(prey_dirL(1),prey_dirL(2),prey_dirL(3));
            
            % Current sequence
            sq = seqs(j);
            
            % Store results
            r.pred_spd(sq,1)  = spds(i);
            r.spd_rost(sq,1)  = spd_rost;
            r.spd_tail(sq,1)  = spd_tail;
            r.spd_right{sq}   = spd_right;
            r.spd_left{sq}    = spd_left;
            r.spd_dors{sq}    = spd_dors;
            r.spd_vent{sq}    = spd_vent;
            r.az_dir(sq,1)    = az_dir;
            r.el_dir(sq,1)    = el_dir;
            r.vent(sq,1)      = i_vent(j);
            r.wrong(sq,1)     = i_wrong(j);
            
            if vis_seqs
                plot3([rost1(j,1) tail1(j,1)], ...
                    [rost1(j,2) tail1(j,2)], ...
                    [rost1(j,3) tail1(j,3)],'k',...
                    rost1(j,1),rost1(j,2),rost1(j,3),'ok')
                hold on
                arrow3(com1(j,:),com2(j,:),'r')
                axis equal
                title(['az_dir = ' num2str(az_dir*180/pi) ' deg'])
                xlabel('x');ylabel('y');zlabel('z')
            end
        
        end
        
        
        disp(' ');disp(['Done ' num2str(spds(i)) ' cm/s'])
        
    end % Loop for each speed
    
    % Save cue analysis data
    save([root_path filesep 'bodycue data'],'r')
 
else
    % Load previous 'r' 
    load([root_path filesep 'bodycue data'])
    
end % do_bodycue


%% Visulize rose plots of direction in global FOR (vis_rose_global)

if vis_rose_global
    
    % Index for speed
    i = 3;
    
    % Choose index for sequences that have stage 2 data
    idx = index{i} & ~isnan(b.preyx2(:,2)) & b.preyx(:,1)>0  ...
        & b.preyx(:,2)>0  & b.preyx(:,3)>0;
    
    % Get body points for all seqnences in current speed
    [rost0,com0,tail0,rost1,com1,tail1,rost2,com2,tail2,i_vent,...
        i_wrong,prey_dir] = give_points(b,idx,latency,spds(i)); 

    % Azimuth of responses
    [az,rad] = cart2pol(com2(:,1)-com1(:,1),com2(:,2)-com1(:,2));
    
    % Elevation of responses
    [el,rad] = cart2pol(com2(:,1)-com1(:,1),com2(:,3)-com1(:,3));

    % Flip sign of azimuth for lateral positions, if negative y coordinate
    iFlip = (com1(:,2)<0) & (abs(com1(:,2)) > lat_pos);
    az(iFlip) = -az(iFlip);
    
    % Idices for postion
    iLat  = abs(com1(:,2)) > lat_pos;
    iMed  = abs(com1(:,2)) <= lat_pos;
    iDors = com1(:,3) > 0; 
    iVent = com1(:,3) <= 0;
    
    % Plot
    figure;
    subplot(2,2,1)
    rose_plot(az(iLat),i_wrong(iLat),num_bin)
    title(['Azimuth (lateral) ' num2str(spds(i)) ' cm/s'])
    
    subplot(2,2,3)
    rose_plot(az(iMed),i_wrong(iMed),num_bin)
    title(['Azimuth (medial) ' num2str(spds(i)) ' cm/s'])
    
    subplot(2,2,2)
    rose_plot(el(iDors),i_wrong(iDors),num_bin)
    title(['Elevation (dorsal) ' num2str(spds(i)) ' cm/s'])
    
    subplot(2,2,4)
    rose_plot(el(iVent),i_wrong(iVent),num_bin)
    title(['Elevation (ventral) ' num2str(spds(i)) ' cm/s'])
    
    
end % vis_rose_local


%% Visulize rose plots of direction wrt body (vis_rose_local)

if vis_rose_local

    % Plot direction (az) for rostrum/tail comparisons   
    %rose_wrt_body(b,r,num_bin,index,r.spd_rost,r.spd_tail,'rost','tail','az')
    
    % Plot direction (az) for left/right comparisons    
    %rose_wrt_body(b,r,num_bin,index,r.spd_right,r.spd_left,'right','left','az')
        
    % Plot direction (az) for left/right comparisons with new 'wrong' calc (Bill)   
    rose_wrt_body(b,r,num_bin,index,r.spd_right,r.spd_left,'az')
    
    % Plot direction (el) for dorsal/ventral comparisons    
    %rose_wrt_body(b,r,num_bin,index,r.spd_dors,r.spd_vent,'dors','vent','el')

    scatter_diff(r,index)
    
    
end % vis_rose_local


%% Visualize local flow
% Visualize results of this anlaysis by running vis_3D with do_localflow = 1;

if do_localflow
    
    % Number of points along the x-axis of the body
    num_xpts = 20;
    
    % Range of points along x-axis of body (in body lengths)
    x_rangeL = [-.5 1.5];
    
    % Range of points along y-axis of body (in body lengths)
    y_rangeL = [-0.5 0.5];
    
    % Range of points along the z-axis of body (in body lengths)
    z_rangeL = [-.5 .5];
    
    % Initialize result vectors
    
    nan1  = nan(size(b.preyx(:,1),1),1);
    nan3  = nan(size(b.preyx(:,1),1),3);
    cell1 = cell(size(b.preyx(:,1),1),1);
    
    L.pred_spd = nan1;
    L.rost0    = nan3;
    L.com0     = nan3;
    L.tail0    = nan3;
    L.rost1    = nan3;
    L.com1     = nan3;
    L.tail1    = nan3;
    L.rost2    = nan3;
    L.com2     = nan3;
    L.tail2    = nan3;
    L.front    = cell1;
    L.sag      = cell1;
    L.dirL     = nan3;
    L.az_dirL  = nan1;
    L.el_dirL  = nan1;
    L.wrong    = nan1;
    
    clear nan1 nan3
    
    % Loop through speeds
    for i = 1:3
        
        
        % Load CFD data in 'cR' structure
        load(cfd_path{i})
        
        % Choose index for sequences that have stage 2 data
        idx = index{i} & ~isnan(b.preyx2(:,2)) & b.preyx(:,1)>0  ...
              & b.preyx(:,2)>0  & b.preyx(:,3)>0;
        
        % Sequence numbers 
        seqs = find(idx);
        
        % Get body points for all sequences in current speed
        [rost0,com0,tail0,rost1,com1,tail1,rost2,com2,tail2,i_vent,...
         i_wrong,prey_dir] = give_points(b,idx,latency,spds(i));
        
        % Index of individuals positioned ventral to predator
        i_vent = com0(:,3)<=0;
        
        % Index of all wrong directions based on distance from axis 
        % extending from predator midline (Bill)
        
        %calculate dist from mildline at t1 and t2
        dist1 = (com1(:,2).^2 + com1(:,3).^2).^0.5;
        dist2 = (com2(:,2).^2 + com2(:,3).^2).^0.5;
        
        %those going in wrong direction have smaller d2 
        i_wrong = dist2 < dist1;
        
        clear dist1 dist2
        
                
        % Step thru each sequence for current speed
        for j = 1:length(seqs)

            % Body length of prey
            blength = norm([tail0(j,1)-rost0(j,1) ...
                            tail0(j,2)-rost0(j,2) ...
                            tail0(j,3)-rost0(j,3)]);       
                        
            % Range of volume to interrogate
            rangeX   = [com0(j,1)-blength*sclfactr_bod ...
                        com0(j,1)+blength*sclfactr_bod];
            rangeY   = [com0(j,2)-blength*sclfactr_bod ...
                        com0(j,2)+blength*sclfactr_bod];
            rangeZ   = [com0(j,3)-blength*sclfactr_bod ...
                        com0(j,3)+blength*sclfactr_bod];
            subRange = [rangeX(1) rangeX(2) ...
                        rangeY(1) rangeY(2) ...
                        rangeZ(1) rangeZ(2)];
            
            % Reduce flow field to small volume
            [xS,yS,zS,uS]   = subvolume(cR.x,cR.y,cR.z,cR.u,subRange);
            [xS,yS,zS,vS]   = subvolume(cR.x,cR.y,cR.z,cR.v,subRange);
            [xS,yS,zS,wS]   = subvolume(cR.x,cR.y,cR.z,cR.w,subRange);

            
            clear rangeX rangeY rangeZ subRange
            
            % Define points for the frontal plane of the body
            x_valsF = linspace(blength*x_rangeL(1),...
                               blength*x_rangeL(2),...
                               num_xpts)';
            y_valsF = [blength*y_rangeL(1):...
                       mean(diff(x_valsF)):...
                       blength*y_rangeL(2)]';
            
            % Define points for the saggital plane of the body
            x_valsS = x_valsF;
            z_valsS = [blength*z_rangeL(1):...
                       mean(diff(x_valsS)):...
                       blength*z_rangeL(2)]';
            
            % Meshgrid the frontal and saggital plane coordinates
            [x2F,y2F,z2F] = meshgrid(x_valsF,y_valsF,0);
            [x2S,y2S,z2S] = meshgrid(x_valsS,0,z_valsS);
            
            % Transform coordinates from local to global systems
            [xptsF,yptsF,zptsF] = local_to_global_matrix(rost0(j,:),...
                                      com0(j,:),tail0(j,:),x2F,y2F,z2F);
            [xptsS,yptsS,zptsS] = local_to_global_matrix(rost0(j,:),...
                                      com0(j,:),tail0(j,:),x2S,y2S,z2S);
                                  
            % Interpolate to get flow velocities (frontal plane)                   
            gbl_uF   = griddata(xS,yS,zS,uS,xptsF,yptsF,zptsF);
            gbl_vF   = griddata(xS,yS,zS,vS,xptsF,yptsF,zptsF);
            gbl_wF   = griddata(xS,yS,zS,wS,xptsF,yptsF,zptsF);
            
            % Interpolate to get flow velocities (saggital plane)                   
            gbl_uS   = griddata(xS,yS,zS,uS,xptsS,yptsS,zptsS);
            gbl_vS   = griddata(xS,yS,zS,vS,xptsS,yptsS,zptsS);
            gbl_wS   = griddata(xS,yS,zS,wS,xptsS,yptsS,zptsS);
             
            % Calculate speed
            gbl_spdF = sqrt(gbl_uF.^2 + gbl_vF.^2 + gbl_wF.^2);
            gbl_spdS = sqrt(gbl_uS.^2 + gbl_vS.^2 + gbl_wS.^2);
            
            % Transform velocities back to local system           
            [uF,vF,wF] = global_to_local_flow(rost0(j,:),...
                              com0(j,:),tail0(j,:),...
                              xptsF,yptsF,zptsF,...
                              gbl_uF,gbl_vF,gbl_wF);
                          
            [uS,vS,wS] = global_to_local_flow(rost0(j,:),...
                              com0(j,:),tail0(j,:),...
                              xptsS,yptsS,zptsS,...
                              gbl_uS,gbl_vS,gbl_wS);
                          
            clear gbl_uF gbl_vF gbl_wF gbl_uS gbl_vS gbl_wS
            clear xptsF yptsF zptsF xptsS yptsS zptsS
                          
            % Transform fast start direction wrt prey body
            com2L = global_to_local(rost1(j,:),com1(j,:),tail1(j,:),com2(j,:));
            com1L = global_to_local(rost1(j,:),com1(j,:),tail1(j,:),com1(j,:));
            
            % Calculate fast start direction from local FOR
            prey_dirL(:,1) = com2L(:,1) - com1L(:,1);
            prey_dirL(:,2) = com2L(:,2) - com1L(:,2);
            prey_dirL(:,3) = com2L(:,3) - com1L(:,3);  
            
            % Angle of response wrt body
            [az_dir,el_dir,r_dir] = cart2sph(prey_dirL(1),...
                                             prey_dirL(2),prey_dirL(3));
            
            % Reshape all of the saggital plane points
            new_dim  = [size(x2S,2) size(x2S,3) size(x2S,1)];
            x2S      = reshape(x2S,new_dim);
            y2S      = reshape(y2S,new_dim);
            z2S      = reshape(z2S,new_dim);
            uS       = reshape(uS,new_dim);
            vS       = reshape(vS,new_dim);
            wS       = reshape(wS,new_dim);
            gbl_spdS = reshape(gbl_spdS,new_dim);
                
            if vis_seqs
                figure
                
                % Plot frontal plane
                surf(x2F,y2F,z2F,gbl_spdF)
                axis equal
                shading interp;
                hold on
                h = quiver3(x2F,y2F,z2F,uF,vF,wF,0.5,'k');
                
                % Plot saggital plane
                surf(x2S,y2S,z2S,gbl_spdS)
                h = quiver3(x2S,y2S,z2S,uS,vS,wS,0.5,'k');
                
                % Plot response vector
                h = arrow3([0 0 0],prey_dirL,'k',.5,.5);
                set(h(1),'LineWidth',2)
                shading interp;
                
                colorbar('South')
                title([num2str(spds(i)) ' cm/s, seq ' num2str(seqs(j))])
                
                %k = waitforbuttonpress;
                %close
            end

            % Current sequence
            sq = seqs(j);
            
            % Store results--------------------------
            
            % Predator speed
            L.pred_spd(sq,1)  = spds(i);
            
            % Prey coordinates (global system)
            L.rost0(sq,:) = rost0(j,:);
            L.com0(sq,:)  = com0(j,:);
            L.tail0(sq,:) = tail0(j,:);
            L.rost1(sq,:) = rost1(j,:);
            L.com1(sq,:)  = com1(j,:);
            L.tail1(sq,:) = tail1(j,:);
            L.rost2(sq,:) = rost2(j,:);
            L.com2(sq,:)  = com2(j,:);
            L.tail2(sq,:) = tail2(j,:);
            
            % Front plane flow (local system)
            L.front{sq}.xL  = x2F;
            L.front{sq}.yL  = y2F;
            L.front{sq}.zL  = z2F;
            L.front{sq}.uL  = uF;
            L.front{sq}.vL  = vF;
            L.front{sq}.wL  = wF;
            L.front{sq}.spd = gbl_spdF;
            
            % Saggital plane flow (local system)
            L.sag{sq}.xL  = x2S;
            L.sag{sq}.yL  = y2S;
            L.sag{sq}.zL  = z2S;
            L.sag{sq}.uL  = uS;
            L.sag{sq}.vL  = vS;
            L.sag{sq}.wL  = wS;
            L.sag{sq}.spd = gbl_spdS;
            
            % Prey response
            L.dirL(sq,:)    = prey_dirL;  
            L.az_dirL(sq,1) = az_dir;
            L.el_dirL(sq,1) = el_dir;
            L.wrong(sq,1)   = i_wrong(j);   
            
            clear x2F y2F z2F uF vF wF gbl_spdF prey_dirL az_dir el_dir
            clear gbl_spdF gbl_spdS x2S y2S z2S uS vS wS
            
            
            % Update on sequences
            disp(['      Done ' num2str(j) ' of ' num2str(length(seqs)) ...
                  ' sequences']);

        end
        
        % Update on speeds
        disp(' ');disp(['Done ' num2str(spds(i)) ' cm/s']);disp(' ')
        
    end % Loop for each speed
    
    % Save cue analysis data
    save([root_path filesep 'behavior' filesep 'localflow data'],'L')
 
else
    % Load previous 'L' 
    load([root_path filesep 'behavior' filesep 'localflow data'])
    
end % do_localflow


%% Visualize local flow 2D


if do_localflow2D
    
    % Number of points along the x-axis of the body
    num_xpts = 20;
    
    % Range of points along x-axis of body (in body lengths)
    x_rangeL = [-.5 1.5];
    
    % Range of points along y-axis of body (in body lengths)
    y_rangeL = [-0.5 0.5];
    
    % Range of points along the z-axis of body (in body lengths)
    z_rangeL = [-.5 .5];
    
    % Color of predator
    p_clr = .6.*[1 1 1];
    
    % Color of surface
    s_clr = [102 102 255]./255;
    
    % Good "representative" sequences (for 11 cm/s)
    g_seq = [2 10 15 17];
    
    alpha_val = 0.3;
    
    % Load predator body morphology data
    load([root_path filesep 'morphology' filesep 'Pred3Dbodyshape.mat'])
    
    % Load prey morphology daat, define dimensions ('m')
    load([root_path filesep 'morphology' filesep '6_02_L19_metrics.mat']);
    
    % Define 3d data for prey in local FOR
    [pX,pY,pZ] = prey_surf(m.s,m.h,m.w,m.c,numPts_circ); 
    clear m
    
    % Create figure window
    f1 = figure;
    
    % Subplot
    %subplot(4,2,[1 3 5 7])
    
    % Render the predator body
    h1 = patch(real(pred3DshapeX),real(pred3DshapeY),...
        real(pred3DshapeZ),real(pred3DshapeX)*0);
    
    set(h1,'FaceLighting','gouraud',...
        'LineStyle','none',...
        'BackFaceLighting','reverselit',...
        'FaceColor',p_clr,...
        'AmbientStrength',.5);
    
    view(2)
    light('position',[60,60,0])
    %light('position',[0,-60,60])
    light('position',[0,-60,-30])
    %xlim([-1 1.5])
    
    set(gca,'XColor','w')
    set(gca,'YColor','w')
    set(gca,'ZColor','w')
    zoom(1.75)
    
    
    % Index for approach speed
    i = 2;
    
    % Load CFD data in 'cR' structure
    load(cfd_path{i})
    
    % Choose index for sequences that have stage 2 data
    idx = index{i} & ~isnan(b.preyx2(:,2)) & b.preyx(:,1)>0  ...
        & b.preyx(:,2)>0  & b.preyx(:,3)>0;
    
    % Sequence numbers
    seqs = find(idx);
    
    % Get body points for all sequences in current speed
    [rost0,com0,tail0,rost1,com1,tail1,rost2,com2,tail2,i_vent,...
        i_wrong,prey_dir] = give_points(b,idx,latency,spds(i));
    
    % Index of individuals positioned ventral to predator
    i_vent = com0(:,3)<=0;
    
    % Index of all wrong directions based on distance from axis
    % extending from predator midline (Bill)
    
    %calculate dist from mildline at t1 and t2
    dist1 = (com1(:,2).^2 + com1(:,3).^2).^0.5;
    dist2 = (com2(:,2).^2 + com2(:,3).^2).^0.5;
    
    %those going in wrong direction have smaller d2
    i_wrong = dist2 < dist1;
    
    clear dist1 dist2
    
    % Step thru each sequence for current speed
    for k = 1:length(g_seq);
        
        j = g_seq(k);
        
        % Body length of prey
        blength = norm([tail0(j,1)-rost0(j,1) ...
            tail0(j,2)-rost0(j,2) ...
            tail0(j,3)-rost0(j,3)]);
        
        % Range of volume to interrogate
        rangeX   = [com0(j,1)-blength*sclfactr_bod ...
            com0(j,1)+blength*sclfactr_bod];
        rangeY   = [com0(j,2)-blength*sclfactr_bod ...
            com0(j,2)+blength*sclfactr_bod];
        rangeZ   = [com0(j,3)-blength*sclfactr_bod ...
            com0(j,3)+blength*sclfactr_bod];
        subRange = [rangeX(1) rangeX(2) ...
            rangeY(1) rangeY(2) ...
            rangeZ(1) rangeZ(2)];
        
        % Reduce flow field to small volume
        [xS,yS,zS,uS]   = subvolume(cR.x,cR.y,cR.z,cR.u,subRange);
        [xS,yS,zS,vS]   = subvolume(cR.x,cR.y,cR.z,cR.v,subRange);
        [xS,yS,zS,wS]   = subvolume(cR.x,cR.y,cR.z,cR.w,subRange);
        
        clear rangeX rangeY rangeZ subRange
        
        % Define points for the frontal plane of the body
        x_valsF = linspace(blength*x_rangeL(1),...
            blength*x_rangeL(2),...
            num_xpts)';
        y_valsF = [blength*y_rangeL(1):...
            mean(diff(x_valsF)):...
            blength*y_rangeL(2)]';
        
        % Meshgrid the frontal plane coordinates
        [x2F,y2F,z2F] = meshgrid(x_valsF,y_valsF,0);
        
        % Transform coordinates from local to global systems
        [xptsF,yptsF,zptsF] = local_to_global_matrix(rost0(j,:),...
            com0(j,:),tail0(j,:),x2F,y2F,z2F);
        
        % Interpolate to get flow velocities (frontal plane)
        gbl_uF   = griddata(xS,yS,zS,uS,xptsF,yptsF,zptsF);
        gbl_vF   = griddata(xS,yS,zS,vS,xptsF,yptsF,zptsF);
        gbl_wF   = griddata(xS,yS,zS,wS,xptsF,yptsF,zptsF);
        
        % Calculate speed
        gbl_spdF = sqrt(gbl_uF.^2 + gbl_vF.^2 + gbl_wF.^2);
        
        % Transform velocities back to local system
        [uF,vF,wF] = global_to_local_flow(rost0(j,:),...
            com0(j,:),tail0(j,:),...
            xptsF,yptsF,zptsF,...
            gbl_uF,gbl_vF,gbl_wF);
        
        clear gbl_uF gbl_vF gbl_wF
        clear xptsF yptsF zptsF
        
        % Transform fast start direction wrt prey body
        com2L = global_to_local(rost1(j,:),com1(j,:),tail1(j,:),com2(j,:));
        com1L = global_to_local(rost1(j,:),com1(j,:),tail1(j,:),com1(j,:));
        
        % Calculate fast start direction from local FOR
        prey_dirL(:,1) = com2L(:,1) - com1L(:,1);
        prey_dirL(:,2) = com2L(:,2) - com1L(:,2);
        prey_dirL(:,3) = com2L(:,3) - com1L(:,3);
        
        % Angle of response wrt body
        [az_dir,el_dir,r_dir] = cart2sph(prey_dirL(1),...
            prey_dirL(2),prey_dirL(3));
        
        
        % PLOT RESULTS ------------------------------------------------
        
        figure(f1);
        %subplot(4,2,[1 3 5 7])
        
        if k==1
            % Isosurface
            [faces,verts] = isosurface(cR.x,cR.y,cR.z,smooth3(cR.spd),spd_thresh);
            p = patch('Vertices', verts, 'Faces', faces, ...
                'FaceColor','interp', ...
                'edgecolor', 'interp');
            set(p,'FaceColor',s_clr,'EdgeColor','none');
            daspect([1,1,1])
            %view(3);
            axis tight
            %camlight
            lighting gouraud
            alpha(p,alpha_val)
            xlims = xlim;
            ylims = ylim;
            zlims = zlim;
            hold on
            %xlabel('x'),ylabel('y'),zlabel('z')
        end
        
        % This is supposed to smooth the surface plot
        %isonormals(cR.x,cR.y,cR.z,cR.spd,p);
        
        hG = plot3(...
            [com1(j,1) com2(j,1)],...
            [com1(j,2) com2(j,2)],...
            [com1(j,3) com2(j,3)],'r-');
        set(hG,'LineWidth',0.5)
        
        % Body length of prey
        blength = norm([tail0(j,1)-rost0(j,1) ...
            tail0(j,2)-rost0(j,2) ...
            tail0(j,3)-rost0(j,3)]);
        
        % Returns coordinates for prey body in global FOR
        [pXg,pYg,pZg] = prey_global(rost1(j,:),com1(j,:),tail1(j,:),...
            pX,pY,pZ);
        
        % Render the prey
        h1 = patch(real(pXg),real(pYg),real(pZg),real(pZg)*0);
        
        % Set properties
        set(h1,'FaceLighting','gouraud',...
            'LineStyle','none',...
            'BackFaceLighting','reverselit',...
            'FaceColor',preyColor,...
            'AmbientStrength',.5);
        
        hold on
        
        
        fname = ['img' num2str(k)];
        
        f2 = figure;
        
        %subplot(4,1,2*k)
        
        % Plot frontal plane
        %subplot(2,1,1)
        hp = pcolor(x2F,y2F,gbl_spdF);
        axis equal
        shading interp;
        caxis([0 .2])
        colorbar
        
        set(gca,'XColor','w')
        set(gca,'YColor','w')
        set(gca,'ZColor','w')

        
        print(f2,'-djpeg',[root_path filesep 'figures' filesep fname '.jpeg'])
        
        
        %alpha(0.5)
        %hold on
        
        %subplot(2,1,2)
        h = quiver(x2F,y2F,uF,vF,0.5,'k');
        axis equal
        hold on
        
        % Render the prey
        h1 = patch(real(pX),real(pY),real(pZ)*0);
        
        % Set properties
        set(h1,...
            'LineStyle','none',...
            'FaceColor','k',...
            'AmbientStrength',.5);
        
        hold on
        %light('position',[60,60,0])
        
        % Plot response vector
        h = plot([0 prey_dirL(1)]+com1L(1),[0 prey_dirL(2)],'r-');
        set(h(1),'LineWidth',0.5)
        
       % shading interp;
        
       if k==4
        %colorbar('SouthOutside')
       end
       
        title([num2str(spds(i)) ' cm/s, j = ' num2str(j)])
        
        set(gca,'XColor','w')
        set(gca,'YColor','w')
        set(gca,'ZColor','w')
    %zoom(1.75)
        
        print(f2,'-depsc',[root_path filesep 'figures' filesep fname '.eps'])
        
        %pause(1)
        
        close(f2)
    end
    
    set(gca,'XColor','w')
    set(gca,'YColor','w')
    set(gca,'ZColor','w')
    
end % do_localflow2D


%% Plot 3D spatial distibution of responders (do_3D)

if do_position  
    
    % Color of correct direction
    c_clr = [0 127 0]./255;
    
    % Color of wrong direction
    w_clr = [255 0 0]./255;
    
    % Colors for each speed
    c_spd = [1 0 1;.5 .5 0;0 .5 1];
        
    % New Figure window
    figure 
        
    % Step through each speed
    for i = 1:3
        
        % Load CFD data in 'cR' strcuture
        load(cfd_path{i})
                
        % Choose index for sequences that have stage 2 data
        idx = index{i} & ~isnan(b.preyx2(:,2)) & b.preyx(:,1)>0  ...
              & b.preyx(:,2)>0  & b.preyx(:,3)>0;
        
        % Get body points for all seqnences in current speed
        [rost0,com0,tail0,rost1,com1,tail1,rost2,com2,tail2,i_vent,...
            i_wrong,prey_dir] = give_points(b,idx,latency,spds(i));
                
        % 3D plot of speed and resposes -----------------------------------
        
        % Plot of position at response
        %subplot(1,2,1)
        
        for j = 1:size(com1,1)
            subplot(2,1,1)
            % Plot location of larvae
            h = plot(com1(j,1),abs(com1(j,2)),'o');
            set(h,'Color',c_spd(i,:))
            hold on
            axis equal
            
            subplot(2,1,2)
            % Plot location of larvae
            h = plot(com1(j,1),com1(j,3),'o');
            set(h,'Color',c_spd(i,:))
            hold on
            axis equal
            
            % Remove location of larvae
            %delete(h)
        end

        %title(['Speed (' num2str(spds(i)) ' cm/s)'])
        xlims = xlim;
        ylims = ylim;
        zlims = zlim;
        
        pause(1)
    end   
    
    %set(gca,'XColor','w')
    %set(gca,'YColor','w')
    %set(gca,'ZColor','w')
    %zoom(1.75)
    
    
end



function rose_plot(az,wrong,num_bin)
    
% Rose plot in correct direction
h = rose(az(~wrong),num_bin);
set(h,'Color','g')
hold on

% Rose plot of wrong direction
if sum(wrong)>0
    h = rose(az(wrong),num_bin);
    set(h,'Color','r')
end

% Calculate and plot mean and CIs
[mu,l1,l2] = circ_mean(az);
h = polar([mu mu],[0 max(abs(ylim))]);
set(h,'Color','k')
h = polar([l1 l1],[0 max(abs(ylim))]);
set(h,'Color','k')
set(h,'LineStyle','--')
h = polar([l2 l2],[0 max(abs(ylim))]);
set(h,'Color','k')
set(h,'LineStyle','--')


function rose_wrt_body(b,r,num_bin,index,R_spd,L_spd,angl)
% Creates rose plots of response diretcion wrt the prey body for different
% categories that are defined by differences in flow along two regions of
% the body

% Speed values
spds = [2 11 20];

% Define angle
if strcmp(angl,'az')
    dir = r.az_dir;
elseif strcmp(angl,'el')
    dir = r.el_dir;
else
    error('angle not recognized')
end

% Define max on each side of body for all seqs
for i = 1:length(R_spd)
    if isempty(R_spd{i})
        Rmax(i,1) = nan;
    else
        Rmax(i,1) = max(R_spd{i});
    end
    
    if isempty(L_spd{i})
        Lmax(i,1) = nan;
    else
        Lmax(i,1) = max(L_spd{i});
    end   
end

% Step through each speed
for i = 1:3
    
    % Index for right > left
    idx = index{i} & ~isnan(Rmax) & ~isnan(dir) & (Rmax>Lmax);
    
    % Plot
    subplot(2,3,i)
    rose_plot(dir(idx),r.wrong(idx)==1,num_bin);
    title([num2str(spds(i)) ' cm/s  R > L'])
    
    % Index for left > right
    idx = index{i} & ~isnan(Rmax) & ~isnan(dir) & (Rmax<Lmax);
    
    % Plot
    subplot(2,3,3+i)
    rose_plot(dir(idx),r.wrong(idx)==1,num_bin);
    title([num2str(spds(i)) ' cm/s  R < L'])
    
end


function ptsT = global_to_local(rost,com,tail,pts)
% Transforms coordinates (pts, in n x 3) from global to local coordinate
% system, assuming the y-axis of larvae runs perpendicular to gravity

% Check dimensions
if size(rost,1)~=1 || size(rost,2)~=3 || size(com,1)~=1 | size(com,2)~=3 ...
   size(tail,1)~=1 || size(tail,2)~=3 || size(pts,2)~=3 
    error('inputs have incorrect dimensions')
end

% Retrieve local x axis to determine coordinate system
xaxis(1,1) = tail(1) - rost(1);
xaxis(1,2) = tail(2) - rost(2);
xaxis(1,3) = tail(3) - rost(3);

% Normalize to create a unit vector
xaxis = xaxis./norm(xaxis);

%Determine local y axis
%Short hand of cross product of inertial z axis and local x axis
yaxis = [-xaxis(2) xaxis(1) 0];

% Normalize to create a unit vector
yaxis = yaxis./norm(yaxis);

%Determine local z axis
zaxis = cross(xaxis,yaxis);

% Normalize to create a unit vector
zaxis = zaxis./norm(zaxis);

%Create rotation matrix (from inertial axes to local axes)
R = [xaxis' yaxis' zaxis'];

% Translate global coordinates wrt rostrum
ptsT(:,1) = pts(:,1) - rost(1);
ptsT(:,2) = pts(:,2) - rost(2);
ptsT(:,3) = pts(:,3) - rost(3);

% Rotate points
ptsT = [inv(R) * ptsT']';

% Visualize to test
if 0
    
    blength = norm([tail(1)-rost(1) tail(2)-rost(2) tail(3)-rost(3)]);    
    
    figure
    
    subplot(2,2,[1 3])
    plot3([tail(1) rost(1)],[tail(2) rost(2)],[tail(3) rost(3)],'b',...
          rost(1),rost(2),rost(3),'bo');
    hold on
    plot3(pts(:,1),pts(:,2),pts(:,3),'ro')
    xlabel('x'); ylabel('y'); zlabel('z')
    hold off
    grid on;axis equal
    view(3)
    title('global')
    
    subplot(2,2,2)
    plot([0 blength],[0 0],'b',0,0,'ob',ptsT(:,1),ptsT(:,2),'ro')
    xlabel('x');ylabel('y')
    grid on; axis equal
    title('local')
    
    subplot(2,2,4)
    plot([0 blength],[0 0],'b',0,0,'ob',ptsT(:,1),ptsT(:,3),'ro')
    xlabel('x');ylabel('z')
    grid on; axis equal
end


function ptsT = local_to_global(rost,com,tail,pts)
% Transforms coordinates (pts, in n x 3) from global to local coordinate
% system, assuming the y-axis of larvae runs perpendicular to gravity

% Check dimensions of landmark coordinates
if size(rost,1)~=1 || size(rost,2)~=3 || size(com,1)~=1 | size(com,2)~=3 ...
   size(tail,1)~=1 || size(tail,2)~=3
    error('inputs have incorrect dimensions')
end

% Retrieve local x axis to determine coordinate system
xaxis(1,1) = tail(1) - rost(1);
xaxis(1,2) = tail(2) - rost(2);
xaxis(1,3) = tail(3) - rost(3);

% Normalize to create a unit vector
xaxis = xaxis./norm(xaxis);

%Determine local y axis
%Short hand of cross product of inertial z axis and local x axis
yaxis = [-xaxis(2) xaxis(1) 0];

% Normalize to create a unit vector
yaxis = yaxis./norm(yaxis);

%Determine local z axis
zaxis = cross(xaxis,yaxis);

% Normalize to create a unit vector
zaxis = zaxis./norm(zaxis);

%Create rotation matrix (from inertial axes to local axes)
R = [xaxis' yaxis' zaxis'];

% If points are not meshgridded
if size(pts,2)==3
    % Rotate points
    ptsT = [R * pts']';
    
    % Translate global coordinates wrt rostrum
    ptsT(:,1) = ptsT(:,1) + rost(1);
    ptsT(:,2) = ptsT(:,2) + rost(2);
    ptsT(:,3) = ptsT(:,3) + rost(3);
    
else
    error('points need to be arranged in 3 columns')
    
end

% Visualize to test
if 0
    
    blength = norm([tail(1)-rost(1) tail(2)-rost(2) tail(3)-rost(3)]);    
    
    figure
    
    subplot(2,2,[1 3])
    plot3([tail(1) rost(1)],[tail(2) rost(2)],[tail(3) rost(3)],'b',...
          rost(1),rost(2),rost(3),'bo');
    hold on
    plot3(ptsT(:,1),ptsT(:,2),ptsT(:,3),'ro')
    xlabel('x'); ylabel('y'); zlabel('z')
    hold off
    grid on;axis equal
    view(3)
    title('global')
    
    subplot(2,2,2)
    plot([0 blength],[0 0],'b',0,0,'ob',pts(:,1),pts(:,2),'ro')
    xlabel('x');ylabel('y')
    grid on; axis equal
    title('local')
    
    subplot(2,2,4)
    plot([0 blength],[0 0],'b',0,0,'ob',pts(:,1),pts(:,3),'ro')
    xlabel('x');ylabel('z')
    grid on; axis equal
end


function [xT,yT,zT] = global_to_local_matrix(rost,com,tail,xpts,ypts,zpts)
% Transforms coordinates (pts, in n x 3) from global to local coordinate
% system, assuming the y-axis of larvae runs perpendicular to gravity

% Check dimensions
if size(rost,1)~=1 || size(rost,2)~=3 || size(com,1)~=1 || size(com,2)~=3 ...
   size(tail,1)~=1 || size(tail,2)~=3 
    error('inputs have incorrect dimensions')
end

% Retrieve local x axis to determine coordinate system
xaxis(1,1) = tail(1) - rost(1);
xaxis(1,2) = tail(2) - rost(2);
xaxis(1,3) = tail(3) - rost(3);

% Normalize to create a unit vector
xaxis = xaxis./norm(xaxis);

%Determine local y axis
%Short hand of cross product of inertial z axis and local x axis
yaxis = [-xaxis(2) xaxis(1) 0];

% Normalize to create a unit vector
yaxis = yaxis./norm(yaxis);

%Determine local z axis
zaxis = cross(xaxis,yaxis);

% Normalize to create a unit vector
zaxis = zaxis./norm(zaxis);

%Create rotation matrix (from inertial axes to local axes)
R = [xaxis' yaxis' zaxis'];

% Translate global coordinates wrt rostrum
xptsT = xpts - rost(1);
yptsT = ypts - rost(2);
zptsT = zpts - rost(3);

% Rotate points
%ptsT = [inv(R) * ptsT']';

% Transformation
for i = 1:size(xptsT,2)
    
    for j = 1:size(xptsT,3)
        ptsT = [xptsT(:,i,j) yptsT(:,i,j) zptsT(:,i,j)];
        
        % Rotate points
        ptsT = [inv(R) * ptsT']';
        
        % Store
        xT(:,i,j) = ptsT(:,1);
        yT(:,i,j) = ptsT(:,2);
        zT(:,i,j) = ptsT(:,3);    
    end    
end


function [uT3,vT3,wT3] = global_to_local_flow(rost,com,tail,x,y,z,u,v,w)
% Transforms coordinates (pts, in n x 3) from global to local coordinate
% system, assuming the y-axis of larvae runs perpendicular to gravity

% Check dimensions
if size(rost,1)~=1 || size(rost,2)~=3 || size(com,1)~=1 || size(com,2)~=3 ...
   size(tail,1)~=1 || size(tail,2)~=3 
    error('inputs have incorrect dimensions')
end

% Retrieve local x axis to determine coordinate system
xaxis(1,1) = tail(1) - rost(1);
xaxis(1,2) = tail(2) - rost(2);
xaxis(1,3) = tail(3) - rost(3);

% Normalize to create a unit vector
xaxis = xaxis./norm(xaxis);

%Determine local y axis
%Short hand of cross product of inertial z axis and local x axis
yaxis = [-xaxis(2) xaxis(1) 0];

% Normalize to create a unit vector
yaxis = yaxis./norm(yaxis);

%Determine local z axis
zaxis = cross(xaxis,yaxis);

% Normalize to create a unit vector
zaxis = zaxis./norm(zaxis);

%Create rotation matrix (from inertial axes to local axes)
R = [xaxis' yaxis' zaxis'];

% Translate global coordinates wrt rostrum
uT = (x + u) - rost(1);
vT = (y + v) - rost(2);
wT = (z + w) - rost(3);

xT = x - rost(1);
yT = y - rost(2);
zT = z - rost(3);

% Rotate points
%ptsT = [inv(R) * ptsT']';

% Transformation
for i = 1:size(uT,2)
    
    for j = 1:size(uT,3)
        
        pts   = [xT(:,i,j) yT(:,i,j) zT(:,i,j)];
        vects = [uT(:,i,j) vT(:,i,j) wT(:,i,j)];
        
        % Rotate points
        vects = [inv(R) * vects']';
        pts   = [inv(R) * pts']';
        
        % Store vector components
        uT2(:,i,j) = vects(:,1);
        vT2(:,i,j) = vects(:,2);
        wT2(:,i,j) = vects(:,3);   
        
        % Store coordinates
        xT2(:,i,j) = pts(:,1);
        yT2(:,i,j) = pts(:,2);
        zT2(:,i,j) = pts(:,3);
    end    
end

uT3 = uT2 - xT2;
vT3 = vT2 - yT2;
wT3 = wT2 - zT2;


function [xptsT,yptsT,zptsT] = local_to_global_matrix(rost,com,tail,xpts,ypts,zpts)
% Transforms coordinates (pts, in n x 3) from global to local coordinate
% system, assuming the y-axis of larvae runs perpendicular to gravity

% Check dimensions of landmark coordinates
if size(rost,1)~=1 || size(rost,2)~=3 || size(com,1)~=1 | size(com,2)~=3 ...
   size(tail,1)~=1 || size(tail,2)~=3
    error('inputs have incorrect dimensions')
end

% Retrieve local x axis to determine coordinate system
xaxis(1,1) = tail(1) - rost(1);
xaxis(1,2) = tail(2) - rost(2);
xaxis(1,3) = tail(3) - rost(3);

% Normalize to create a unit vector
xaxis = xaxis./norm(xaxis);

%Determine local y axis
%Short hand of cross product of inertial z axis and local x axis
yaxis = [-xaxis(2) xaxis(1) 0];

% Normalize to create a unit vector
yaxis = yaxis./norm(yaxis);

%Determine local z axis
zaxis = cross(xaxis,yaxis);

% Normalize to create a unit vector
zaxis = zaxis./norm(zaxis);

%Create rotation matrix (from inertial axes to local axes)
R = [xaxis' yaxis' zaxis'];

% Transformation
for i = 1:size(xpts,2)
    
    for j = 1:size(xpts,3)
        pts = [xpts(:,i,j) ypts(:,i,j) zpts(:,i,j)];
        
        % Rotate points
        ptsT = [R * pts']';
        
        % Store
        xptsT(:,i,j) = ptsT(:,1) + rost(1);
        yptsT(:,i,j) = ptsT(:,2) + rost(2);
        zptsT(:,i,j) = ptsT(:,3) + rost(3);    
    end    
end


function scatter_plot(pred,meas,index)

% All predicted values
p_pool = [pred(index{1}) ; ...
          pred(index{2}) ;...
          pred(index{3}) ];
     
% Range of predicted values
pred_range = [min(p_pool) max(p_pool)];

% All measurements
m_pool = [meas(index{1}); ...
          meas(index{2}); ...
          meas(index{3})];

% Run regression on all data together
[c,cint,res,resint,stats] = regress(m_pool,[ones(length(p_pool),1) p_pool]);

plot(pred(index{1}),meas(index{1}),'ro',...
     pred(index{2}),meas(index{2}),'bo',...
     pred(index{3}),meas(index{3}),'go',...
     [pred_range(1) pred_range(2)],c(2).*[pred_range(1) pred_range(2)]+c(1),'k--');
 
 %[pred_range(1) pred_range(2)],[pred_range(1) pred_range(2)],'k-',...
 
title(['r2=' num2str(stats(1)) ' p=' num2str(stats(3))]) 
axis square
legend('2','11','20','Location','NorthWest') 


function scatter_diff(r,index)
% Look at relationship between velocity difference and response angle

% List of all usable sequences
seqs = find(~isnan(r.az_dir));

% Speed values
spds = [2 11 20];

% Empty vector of L/R speed differences
Dspd = nan(length(r.az_dir),1);

% Loop through squences, recording difference in speed
for i = 1:length(seqs)
    
    % Difference in speed between 1 and 2
    cDiff = r.spd_left{seqs(i)} - r.spd_right{seqs(i)};
        
    % Idenx of position where greatest
    iBod = find(abs(cDiff)==max(abs(cDiff)),1,'first');
    
    % Difference in speed between 1 and 2
    Dspd(seqs(i)) = cDiff(iBod);
    
end

% Index of usable points for each speed
idx{1} = index{1} & ~isnan(r.az_dir);
idx{2} = index{2} & ~isnan(r.az_dir);
idx{3} = index{3} & ~isnan(r.az_dir);


figure

plot(Dspd(idx{1}),(180/pi).*r.az_dir(idx{1}),'ro',...
     Dspd(idx{2}),(180/pi).*r.az_dir(idx{2}),'bo',...
     Dspd(idx{3}),(180/pi).*r.az_dir(idx{3}),'go')
ylabel('azimuth (deg)')
xlabel('difference in L-R velocity')
legend('2','11','20','Location','NorthWest') 

     
function  [rost0,com0,tail0,rost1,com1,tail1,rost2,com2,tail2,i_vent,...
           i_wrong,prey_dir] = give_points(b,idx,latency,spd)
% Returns the points of the prey body for all sequences denoted by 'idx'
       
% Offset in x, due to latency
lat_offset = latency * spd;

% Position (wrt predator) of body points when flow sensed
rost0 = [b.preyx(idx,1)+lat_offset b.preyy(idx,1) b.preyz(idx,1)];
com0  = [b.preyx(idx,2)+lat_offset b.preyy(idx,2) b.preyz(idx,2)];
tail0 = [b.preyx(idx,3)+lat_offset b.preyy(idx,3) b.preyz(idx,3)];

% Position (wrt predator) of body points when larva first moves
rost1 = [b.preyx(idx,1) b.preyy(idx,1) b.preyz(idx,1)];
com1  = [b.preyx(idx,2) b.preyy(idx,2) b.preyz(idx,2)];
tail1 = [b.preyx(idx,3) b.preyy(idx,3) b.preyz(idx,3)];

% Position (wrt predator) of body points at end of stage 2
rost2 = [b.preyx2(idx,1) b.preyy2(idx,1) b.preyz2(idx,1)];
com2  = [b.preyx2(idx,2) b.preyy2(idx,2) b.preyz2(idx,2)];
tail2 = [b.preyx2(idx,3) b.preyy2(idx,3) b.preyz2(idx,3)];

% Find direction of response
prey_dir(:,1) = com2(:,1) - com1(:,1);
prey_dir(:,2) = com2(:,2) - com1(:,2);
prey_dir(:,3) = com2(:,3) - com1(:,3);

% Calculate dist from midline at t1 and t2
dist1 = sqrt(com1(:,2).^2 + com1(:,3).^2);
dist2 = sqrt(com2(:,2).^2 + com2(:,3).^2);

% Index of individuals positioned ventral to predator
i_vent = com0(:,3)<=0;

% Index of responses in the 'wrong' direction
i_wrong = dist2 < dist1;


function plot_prey_pos(f,spd_index)


idx = find(spd_index);
for i = 1:length(idx)
    plot3([f.xbod(idx(i),1) f.xbod(idx(i),end)],...
          [f.ybod(idx(i),1) f.ybod(idx(i),end)],...
          [f.zbod(idx(i),1) f.zbod(idx(i),end)],'-k',...
           f.xbod(idx(i),1),f.ybod(idx(i),1),f.zbod(idx(i),1),'ok');
    hold on
end
axis equal
xlims = xlim;

plot3([xlims(1) 0],[0 0],[0 0],'r-',0,0,0,'or')

grid on
hold off

xlabel('x')
ylabel('y')
zlabel('z')

view([0 90])


function [pos,vect_norm] = cal_norms(faces,verts)
% Finds the postion and direction of vectors normal to a 3D surface

% First vectors directed between verticies
vect1 = verts(faces(:,2),:)-verts(faces(:,1),:);

% Second vectors between verticies
vect2 = verts(faces(:,3),:)-verts(faces(:,1),:);

% Normal vectors
vect_norm = cross(vect2,vect1,2);

% Magnitude of normal vectors
norm_mag = sqrt(vect_norm(:,1).^2 + vect_norm(:,2).^2 + vect_norm(:,3).^2);

%Normalize the normal vectors
vect_norm = [vect_norm(:,1)./norm_mag ...
    vect_norm(:,2)./norm_mag ...
    vect_norm(:,3)./norm_mag];

% Position of normal vectors (centered btwn verticies)
pos(:,1) = mean([verts(faces(:,1),1) ...
    verts(faces(:,2),1) ...
    verts(faces(:,3),1)],2);
pos(:,2) = mean([verts(faces(:,1),2) ...
    verts(faces(:,2),2) ...
    verts(faces(:,3),2)],2);
pos(:,3) = mean([verts(faces(:,1),3) ...
    verts(faces(:,2),3) ...
    verts(faces(:,3),3)],2);


function [X,Y,Z]= prey_surf(s,h,w,c,numPts)
% Provides 3d coordinates of the body

% Define radial positions along vector
theta = linspace(0,2*pi,numPts)';

% Define empty vectors for coordinates
x=[];y=[];z=[];

% Make mouth cap  _______________________________________
n = numPts/10;
phi = linspace(0,.75*pi/2,n)';
ds = .02.*range(s); %2*s(2)-s(1);
%sC = linspace(s(1)-ds,s(1),n);
hC = h(1) .* sin(phi)./max(sin(phi));
wC = w(1) .* sin(phi)./max(sin(phi));
sC = -(ds.*cos(phi)-ds.*cos(phi(end)));

% Loop down the body length
for i=1:length(sC)-1  
    
  % Draw first ellipse   
    yTemp1 = sC(i)*ones(size(theta));
    xTemp1 = (wC(i)/2) .* cos(theta);
    zTemp1 = (hC(i)/2) .* sin(theta) + c(1);
    
  % Draw second ellipse  
    yTemp2 = sC(i+1)*ones(size(theta));
    xTemp2 = (wC(i+1)/2) .* cos(theta);
    zTemp2 = (hC(i+1)/2) .* sin(theta) + c(1);
    
  % Combine data (works with 'patch')
    x	= [x [xTemp1(1:end-1)';... 
              xTemp2(1:end-1)';... 
              xTemp2(2:end)';... 
              xTemp1(2:end)']];
                      
    y   = [y [yTemp1(1:end-1)';... 
              yTemp2(1:end-1)';...
              yTemp2(2:end)';...
              yTemp1(2:end)']];
                      
    z   = [z [zTemp1(1:end-1)';...
              zTemp2(1:end-1)';...
              zTemp2(2:end)';...
              zTemp1(2:end)']];
end 

clear xTemp1 yTemp1 zTemp1 xTemp2 yTemp2 zTemp2
clear n phi ds sC hC wC


% Make body coordinates _______________________________________

% Loop down the body length
for i=1:length(s)-1  
    
  % Draw first ellipse  
    yTemp1      = s(i)*ones(size(theta));
    xTemp1      = (w(i)/2) .* cos(theta);
    zTemp1      = (h(i)/2) .* sin(theta) + c(i);
    
  % Draw second ellipse    
    yTemp2      = s(i+1)*ones(size(theta));
    xTemp2      = (w(i+1)/2) .* cos(theta);
    zTemp2      = (h(i+1)/2) .* sin(theta) + c(i+1);
    
  % Combine data (works with 'patch')
    x	= [x [xTemp1(1:end-1)';... 
              xTemp2(1:end-1)';... 
              xTemp2(2:end)';... 
              xTemp1(2:end)']];
                      
    y   = [y [yTemp1(1:end-1)';... 
              yTemp2(1:end-1)';...
              yTemp2(2:end)';...
              yTemp1(2:end)']];
                      
    z   = [z [zTemp1(1:end-1)';...
              zTemp2(1:end-1)';...
              zTemp2(2:end)';...
              zTemp1(2:end)']];
end  

% Make tail cap  _______________________________________
n = numPts/10;
phi = linspace(0,0.75*pi/2,n)';
ds = .02.*range(s); %2*s(2)-s(1);
%sC = linspace(s(1)-ds,s(1),n);
hC = h(end) .* sin(phi)./max(sin(phi));
wC = w(end) .* sin(phi)./max(sin(phi));
sC = s(end) + ds.*cos(phi)-+ ds.*cos(phi(end));

% Loop down the body length
for i=1:length(sC)-1  
    
  % Draw first ellipse   
    yTemp1 = sC(i)*ones(size(theta));
    xTemp1 = (wC(i)/2) .* cos(theta);
    zTemp1 = (hC(i)/2) .* sin(theta) + c(end);
    
  % Draw second ellipse  
    yTemp2 = sC(i+1)*ones(size(theta));
    xTemp2 = (wC(i+1)/2) .* cos(theta);
    zTemp2 = (hC(i+1)/2) .* sin(theta) + c(end);
    
  % Combine data (works with 'patch')
    x	= [x [xTemp1(1:end-1)';... 
              xTemp2(1:end-1)';... 
              xTemp2(2:end)';... 
              xTemp1(2:end)']];
                      
    y   = [y [yTemp1(1:end-1)';... 
              yTemp2(1:end-1)';...
              yTemp2(2:end)';...
              yTemp1(2:end)']];
                      
    z   = [z [zTemp1(1:end-1)';...
              zTemp2(1:end-1)';...
              zTemp2(2:end)';...
              zTemp1(2:end)']];
end 

clear xTemp1 yTemp1 zTemp1 xTemp2 yTemp2 zTemp2
clear n phi ds sC hC wC

% Transform for units and wrt rostrum
X  = (y-min(y(:))).*100;
Y  = x.*100;
Z  = -(z-z(1)+max(h(:))/2).*100;


function [pXg,pYg,pZg] = prey_global(rost,com,tail,pX,pY,pZ)
% Transforms prey points in global FOR

tmp1 = local_to_global(rost,com,tail,...
                        [pX(1,:)' pY(1,:)' pZ(1,:)']);
tmp2 = local_to_global(rost,com,tail,...
                        [pX(2,:)' pY(2,:)' pZ(2,:)']);
tmp3 = local_to_global(rost,com,tail,...
                        [pX(3,:)' pY(3,:)' pZ(3,:)']);
tmp4 = local_to_global(rost,com,tail,...
                        [pX(4,:)' pY(4,:)' pZ(4,:)']);

pXg = [tmp1(:,1)'; tmp2(:,1)'; tmp3(:,1)'; tmp4(:,1)'];
pYg = [tmp1(:,2)'; tmp2(:,2)'; tmp3(:,2)'; tmp4(:,2)'];
pZg = [tmp1(:,3)'; tmp2(:,3)'; tmp3(:,3)'; tmp4(:,3)'];

