function ana_all(root_path)
% Performs analyses on the data in 'flow_along_body.mat', which is
% generated by ana_body_flow.m



%% Code execution

% Create boxplots of each parameter that could serve as a cue
do_boxplots = 0;

% Plots 3D volumes of flow field and responses
do_3D = 0;

% Compares the direction of flow gradient to direction of behavior
do_directioncue = 0;

% Visualize results of direction cue 
% (visualizes results of do_directioncue)
vis_directcue = 0;

% Descriptive stats of directional response
do_direction = 0;

% Directional responses wrt differences in flow along body
do_bodycue = 1;

% Make rose plots of response direction wrt the body for categories of
% differences in flow (results of do_bodycue)
vis_rose = 1;

% Visualize individual sequences
vis_seqs = 0;

% Simulate response direction assuming prey go directly 90 degrees
% from high flow
do_simulate = 0;

% Visualze flow wrt body of he larvae
do_localflow = 0;


%% Parameters

% Period between detection and fast start initiation (s)
latency = 5e-3;

% Modeled threshold of shearing for a response
sh_thresh = .5;

% Modeled threshold of speed
spd_thresh = .1;

% Relative position of COM along length of the body (this is Matt's guess)
COM_pos = .25;

% Alpha transparency for the isosurface plots
alpha_val = .6;

% Inerval for skipping plotting of normal vectors
norm_skip = 100;

% Scaling of body length for CFD volume examine for isosurface
sclfactr = .25;

% Scaling of body length for CFD volume around whole body
%sclfactr_bod = 1.1;
sclfactr_bod = 1.3;

% Number of bins used in rose plots
num_bin = 20;


%% Paths

if nargin < 1
    root_path = uigetdir(pwd,'Select root directory (holds "cfd" & "behavior")');
end

% Paths to CFD data arranged in regular grid
cfd_path{1}  = [root_path filesep 'cfd' filesep 'flow_02cmps_reggrid.mat'];
cfd_path{2}  = [root_path filesep 'cfd' filesep 'flow_11cmps_reggrid.mat'];
cfd_path{3}  = [root_path filesep 'cfd' filesep 'flow_20cmps_reggrid.mat'];


%% Load data & define variables

% Load flow data long body ('f')
load([root_path filesep 'behavior' filesep 'flow_along_body.mat'])

% Load behavior data ('b')
load([root_path filesep 'behavior' filesep 'Transformed_Prey_Coords.mat'])

% Number of sequences
num_seq = length(b.preyx(:,1));

% Values of speeds
spds = [2 11 20];

% Indices for each speed of sequences in the dark, with lateral line intact
index{1} = (b.speed(1:num_seq)==2) & (b.LL(1:num_seq)==1) ...
     & ~isnan(b.preyx(:,1)) & (b.lit(1:num_seq)==0);

index{2} = (b.speed(1:num_seq)==11) & (b.LL(1:num_seq)==1) ...
     & ~isnan(b.preyx(:,1)) & (b.lit(1:num_seq)==0);
 
index{3} = (b.speed(1:num_seq)==20) & (b.LL(1:num_seq)==1) ...
     & ~isnan(b.preyx(:,1)) & (b.lit(1:num_seq)==0);

% Create groups by speed
groups = [b.speed(index{1}); b.speed(index{2}); b.speed(index{3})];


%% Response boxplots


if do_boxplots
    
%     % Distance of each of the three body points
%     dist1 = sqrt( b.preyx(:,1).^2 + b.preyy(:,1).^2 + b.preyz(:,1).^2 );
%     dist2 = sqrt( b.preyx(:,2).^2 + b.preyy(:,2).^2 + b.preyz(:,2).^2 );
%     dist3 = sqrt( b.preyx(:,3).^2 + b.preyy(:,3).^2 + b.preyz(:,3).^2 );
%     
%     % Use minimum distance as the response distance
%     resp_dist = min([dist1 dist2 dist3],[],2);
    
    % Max speed along body for each speed
    max_bod_spd =  [max(f.spd(index{1},:),[],2); ...
        max(f.spd(index{2},:),[],2); ...
        max(f.spd(index{3},:),[],2)];
    
    % Max velocity gradient along body for each speed
    max_velgrad =  [max(abs(f.velgrad(index{1},:)),[],2); ...
        max(abs(f.velgrad(index{2},:)),[],2); ...
        max(abs(f.velgrad(index{3},:)),[],2)];
    
    % Max shearing along body for each speed
    max_shear   =  [max(f.shrdef(index{1},:),[],2); ...
        max(f.shrdef(index{2},:),[],2); ...
        max(f.shrdef(index{3},:),[],2)];
    
    % Boxplots
    figure;
    
    subplot(2,2,1)
    boxplot(max_bod_spd, groups)
    xlabel('speed (cm/s)')
    ylabel('max speed along body')
    
    subplot(2,2,2)
    boxplot(max_velgrad, groups)
    xlabel('speed (cm/s)')
    ylabel('max vel gradient along body')
    
    subplot(2,2,3)
    boxplot(max_shear, groups)
    xlabel('speed (cm/s)')
    ylabel('max shear deformation along body')  
    
    clear dist1 dist2 dist3 resp_dist max_bod_spd max_velgrad max_shear
end


%% Plot 3D spatial distibution of responders

if do_3D  
    
    p_clr = .5.*[1 1 1];
    
    % Load predator data
    load([root_path filesep 'morphology' filesep 'Pred3Dbodyshape.mat']) 
    
    
    % Step through each speed
    for i = 2 %1:3
        
        % New Figure window
        figure 
        
        % Load CFD data in 'cR' strcuture
        load(cfd_path{i})
        
        
        % Choose index for sequences that have stage 2 data
        idx = index{i} & ~isnan(b.preyx2(:,2)) & b.preyx(:,1)>0  ...
              & b.preyx(:,2)>0  & b.preyx(:,3)>0;
        
        % Get body points for all seqnences in current speed
        [rost0,com0,tail0,rost1,com1,tail1,rost2,com2,tail2,i_vent,...
            i_wrongLR,i_wrongDV,prey_dir] = give_points(b,idx,latency,spds(i));
        
        
        % 3D plot of speed and resposes -----------------------------------
        
        % Plot of position at response
        %subplot(1,2,1)
        
        for j = 1:size(rost1,1)
            plot3([rost1(j,1) tail1(j,1)], ...
                [rost1(j,2) tail1(j,2)], ...
                [rost1(j,3) tail1(j,3)],'k',...
                rost1(j,1),rost1(j,2),rost1(j,3),'ok')
            hold on
            warning off
            arrow3(com1(j,:),com2(j,:),'r')
            warning on
            axis equal
            
        end
%         plot_prey_pos(f,index{i})
         hold on
        title(['Speed (' num2str(spds(i)) ' cm/s)'])
        xlims = xlim;
        ylims = ylim;
        zlims = zlim;
        
        
%         p_idx = pred3DshapeX>min(xlims) & pred3DshapeX<max(xlims) & ...
%                 pred3DshapeY>min(ylims) & pred3DshapeY<max(ylims) & ...
%                 pred3DshapeZ>min(zlims) & pred3DshapeZ<max(zlims);
        
        % Render the predator body
        h1 = patch(real(pred3DshapeX),real(pred3DshapeY),...
               real(pred3DshapeZ),real(pred3DshapeX)*0);
        
        set(h1,'FaceLighting','gouraud',...
               'LineStyle','none',...
               'BackFaceLighting','reverselit',...
               'FaceColor',p_clr,...
               'AmbientStrength',.5);
    
        
        % Isosurface
        [faces,verts] = isosurface(cR.x,cR.y,cR.z,smooth3(cR.spd),spd_thresh);
        p = patch('Vertices', verts, 'Faces', faces, ...
                  'FaceColor','interp', ...
                  'edgecolor', 'interp');
        set(p,'FaceColor','b','EdgeColor','none');
        daspect([1,1,1])
        %view(3);
        axis tight
        camlight
        lighting gouraud
        alpha(p,alpha_val)
        xlims = xlim;
        ylims = ylim;
        zlims = zlim;
        xlabel('x'),ylabel('y'),zlabel('z')
        
        view([165 35])
        light('position',[60,60,60])
        %xlim([-1 1.5])
        
        % This is supposed to smooth the surface plot
        %isonormals(cR.x,cR.y,cR.z,cR.spd,p);       
        
        hold off
        
%         % 3D plot of shearing and resposes --------------------------------
%         
%         % Plot of position at response
%         subplot(1,2,2)
%         %plot_prey_pos(b,index{i})
%         for j = 1:size(rost1,1)
%             plot3([rost1(j,1) tail1(j,1)], ...
%                   [rost1(j,2) tail1(j,2)], ...
%                   [rost1(j,3) tail1(j,3)],'k',...
%                   rost1(j,1),rost1(j,2),rost1(j,3),'ok')
%             arrow3(com1(j,:),com2(j,:),'k')
%         end
%         
%         hold on
%         title(['Shear deformation (' num2str(spds(i)) ' cm/s)'])
%         xlims = xlim;
%         ylims = ylim;
%         zlims = zlim; 
%         
%         hold on
%         
%         % Isosurface
%         p = patch(isosurface(cR.x,cR.y,cR.z,smooth3(cR.sh_def),sh_thresh));
%         isonormals(cR.x,cR.y,cR.z,cR.sh_def,p)
%         set(p,'FaceColor','red','EdgeColor','none');
%         daspect([1,1,1])
%         %view(3);
%         axis tight
%         camlight
%         lighting gouraud
%         alpha(p,alpha_val)
%         
%         hold off
        
    end   
    
end


%% Description of directional response


if do_direction
    
    % Initialize result vectors
    r.pred_spd = nan(size(b.preyx(:,1),1),1);
    r.th_pred  = nan(size(b.preyx(:,1),1),1);
    r.phi_pred = nan(size(b.preyx(:,1),1),1);
    r.th_meas  = nan(size(b.preyx(:,1),1),1);
    r.phi_meas = nan(size(b.preyx(:,1),1),1);
    r.az_prey  = nan(size(b.preyx(:,1),1),1);
    r.el_prey  = nan(size(b.preyx(:,1),1),1);
    
    for i = 1:3
        
        % Choose index for sequences that have stage 2 data
        idx = index{i} & ~isnan(b.preyx2(:,2)) & b.preyx(:,1)>0  ...
              & b.preyx(:,2)>0  & b.preyx(:,3)>0;
          
        % Get body points for all seqnences in current speed
        [rost0,com0,tail0,rost1,com1,tail1,rost2,com2,tail2,i_vent,...
            i_wrongLR,i_wrongDV,prey_dir] = give_points(b,idx,latency,spds(i));
        
        % Spherical coordinates for prey position
        [prey_az,prey_el,prey_r] = cart2sph(com0(:,1),com0(:,2),com0(:,3));
                                        
        % Spherical coordinates for prey direction                                
        [dir_az,dir_el,dir_r] = cart2sph(prey_dir(:,1),prey_dir(:,2),...
                                         prey_dir(:,3));
                                        
%         % Orientation of prey wrt predator on XY plane
%         prey_orient = atan2(prey_pos(:,2)-rost_pos(:,2),...
%                             prey_pos(:,1)-rost_pos(:,1));
                                        
        % Index of indivudual positioned ventral to predator
        i_vent = com0(:,3)<=0;
        
        % Index of L-R responses in the 'wrong' direction
        i_wrong = prey_dir(:,2)<0;
        
        % Index of D-V responses in the 'wrong' direction
        i_wrongDV = (i_vent & (prey_dir(:,3)>0)) |  ...
                    (~i_vent & (prey_dir(:,3)<=0));
        
        if 1
            figure
            subplot(2,3,1)
            
            arrow3(com1(~i_wrongLR,:),com2(~i_wrongLR,:),'g')
            hold on
            arrow3(com1(i_wrongLR,:),com2(i_wrongLR,:),'r')
            hold off
            
            title([num2str(spds(i)) ' cm/s'])
            xlabel('x');ylabel('y');zlabel('z')
            axis equal
            view([0 90])
            
            light('position',[10 10 10],'style','local')
            light('position',[-60,-60,-60]), lighting gouraud
            
            subplot(2,3,2)
            rose(dir_az(~i_vent & ~i_wrongLR),num_bin)
            hold on
            hR = rose(dir_az(~i_vent & i_wrongLR),num_bin);
            set(hR,'Color','r')
            hold off
            title('direction azimuth (dorsal)')
            
            subplot(2,3,3)
            rose(dir_az(i_vent & ~i_wrong),num_bin)
            hold on
            hR = rose(dir_az(i_vent & i_wrong),num_bin);
            set(hR,'Color','r')
            title('direction azimuth (ventral)')
            
            subplot(2,3,4)
            arrow3(com1(~i_wrongDV,:),com2(~i_wrongDV,:),'b')
            hold on
            arrow3(com1(i_wrongDV,:),com2(i_wrongDV,:),'r')
            hold off
            
            title([num2str(spds(i)) ' cm/s'])
            xlabel('x');ylabel('y');zlabel('z')
            axis equal
            view([0 180])
            
            light('position',[10 10 10],'style','local')
            light('position',[-60,-60,-60]), lighting gouraud
            
            subplot(2,3,5)
            rose(dir_el(~i_vent & ~i_wrongDV),num_bin)
            hold on
            hR = rose(dir_el(~i_vent & i_wrongDV),num_bin);
            set(hR,'Color','r')
            hold off
            
            title('direction elevation (dorsal)')
            
            subplot(2,3,6)
            rose(dir_el(i_vent & ~i_wrongDV),num_bin)
            hold on
            hR = rose(dir_el(i_vent & i_wrongDV),num_bin);
            set(hR,'Color','r')
            hold off
            title('direction elevation (ventral)')
            
%             figure
%             plot(prey_orient(~i_wrong),'bo')
%             hold on
%             plot(prey_orient(i_wrong),'ro')
%             title([num2str(spds(i)) ' cm/s'])
%             hold off
        end
        
        clear prey_dir prey_pos lat_offset idx 
    end

end % do_direction


%% Analyze flow cues that predict direction of response

if do_directioncue
    
    % Initialize result vectors
    r.pred_spd = nan(size(b.preyx(:,1),1),1);
    r.th_pred  = nan(size(b.preyx(:,1),1),1);
    r.phi_pred = nan(size(b.preyx(:,1),1),1);
    r.th_meas  = nan(size(b.preyx(:,1),1),1);
    r.phi_meas = nan(size(b.preyx(:,1),1),1);
    r.az_prey  = nan(size(b.preyx(:,1),1),1);
    r.el_prey  = nan(size(b.preyx(:,1),1),1);
    r.wrong    = zeros(size(b.preyx(:,1),1),1);
    r.vent     = zeros(size(b.preyx(:,1),1),1);
    
    % Loop through speeds
    for i = 1:3
        
        if vis_seqs
            figure;
        end
        
        % Choose index for sequences that have stage 2 data
        idx = index{i} & ~isnan(b.preyx2(:,2)) & b.preyx(:,1)>0  ...
              & b.preyx(:,2)>0  & b.preyx(:,3)>0;
        
        % Sequence numbers 
        seqs = find(idx);
        
        % Offset in x, due to latency
        lat_offset = latency * spds(i);
        
        % Load CFD data in 'cR' structure
        load(cfd_path{i})
        
        % Find position of prey
        prey_pos = [b.preyx(idx,2)+lat_offset b.preyy(idx,2) b.preyz(idx,2)];
        
        % Find direction of prey
        prey_dir(:,1) = b.preyx2(idx,2) - b.preyx(idx,2);
        prey_dir(:,2) = b.preyy2(idx,2) - b.preyy(idx,2);
        prey_dir(:,3) = b.preyz2(idx,2) - b.preyz(idx,2);
        
        % Transform prey position, assuming mirror symmetry about the predator
        prey_dir(prey_pos(:,2)<0,2) = -prey_dir(prey_pos(:,2)<0,2);  
        prey_pos(:,2)     = abs(prey_pos(:,2));
        
        % Index of indivudual positioned ventral to predator
        i_vent = prey_pos(:,3)<=0;
        
        % Index of L-R responses in the 'wrong' direction
        i_wrong = prey_dir(:,2)<0;
        
        % Step thru each sequence for current speed
        for j = 1:length(seqs)
            
            % Body length of prey
            blength = norm([b.preyx(seqs(j),3)-b.preyx(seqs(j),1) ...
                            b.preyy(seqs(j),3)-b.preyy(seqs(j),1) ...
                            b.preyz(seqs(j),3)-b.preyz(seqs(j),1)]);
           
            % Range of volume to interrogate
            rangeX   = [prey_pos(j,1)-blength*sclfactr ...
                        prey_pos(j,1)+blength*sclfactr];
            rangeY   = [prey_pos(j,2)-blength*sclfactr ...
                        prey_pos(j,2)+blength*sclfactr];
            rangeZ   = [prey_pos(j,3)-blength*sclfactr ...
                        prey_pos(j,3)+blength*sclfactr];
            subRange = [rangeX(1) rangeX(2) ...
                        rangeY(1) rangeY(2) ...
                        rangeZ(1) rangeZ(2)];
            
            % Reduce flow field to small volume
            [xS,yS,zS,spdS] = subvolume(cR.x,cR.y,cR.z,cR.spd,subRange);
            [xS,yS,zS,uS] = subvolume(cR.x,cR.y,cR.z,cR.u,subRange);
            [xS,yS,zS,vS] = subvolume(cR.x,cR.y,cR.z,cR.v,subRange);
            [xS,yS,zS,wS] = subvolume(cR.x,cR.y,cR.z,cR.w,subRange);
            [xS,yS,zS,xCS] = subvolume(cR.x,cR.y,cR.z,cR.xCurl,subRange);
            [xS,yS,zS,yCS] = subvolume(cR.x,cR.y,cR.z,cR.yCurl,subRange);
            [xS,yS,zS,zCS] = subvolume(cR.x,cR.y,cR.z,cR.zCurl,subRange);
            clear blength rangeX rangeY rangeZ subRange
            
            % Speed at the prey COM
            spd_prey = griddata(xS,yS,zS,spdS,prey_pos(j,1),prey_pos(j,2),prey_pos(j,3));
            
            % Velocity at the prey COM
            u_prey = griddata(xS,yS,zS,uS,prey_pos(j,1),prey_pos(j,2),prey_pos(j,3));
            v_prey = griddata(xS,yS,zS,vS,prey_pos(j,1),prey_pos(j,2),prey_pos(j,3));
            w_prey = griddata(xS,yS,zS,wS,prey_pos(j,1),prey_pos(j,2),prey_pos(j,3));
            
            % Curl at prey COM
            %xC_prey = griddata(xS,yS,zS,xCS,prey_pos(j,1),prey_pos(j,2),prey_pos(j,3));
            %yC_prey = griddata(xS,yS,zS,yCS,prey_pos(j,1),prey_pos(j,2),prey_pos(j,3));
            %zC_prey = griddata(xS,yS,zS,zCS,prey_pos(j,1),prey_pos(j,2),prey_pos(j,3));
            
            % Isosurface in this small volume
            [faces,verts] = isosurface(xS,yS,zS,spdS,spd_prey);
            
            % Calculate normal vectors
            %[pos_norm,vect_norm] = cal_norms(faces,verts);
            
            % Distance between verticies and prey COM
%             dist = sqrt((pos_norm(:,1)-prey_pos(j,1)).^2 +  ...
%                         (pos_norm(:,2)-prey_pos(j,2)).^2 + ...
%                         (pos_norm(:,3)-prey_pos(j,3)).^2);
%                     
%             % Index for normal vector closest to the COM
%             i_norm = find(dist==min(dist));
            
            % Find index for flow data at COM
            %distCOM = abs(f.s(seqs(j),:)./max(f.s(seqs(j),:)) - COM_pos);
            %iCOM = find(distCOM == min(distCOM));
            
            
%              % Flow predicted diretcion, based on velocity and curl
%              tmp = cross([xC_prey,yC_prey,zC_prey],[u_prey,v_prey,w_prey]);
%              tmp = tmp./norm(tmp);
%              xPredict = tmp(1);yPredict = tmp(2);zPredict = tmp(3);
%             [th_pred,phi_pred,r_pred] = cart2sph(tmp(1),...
%                                                  tmp(2),...
%                                                  tmp(3));
            
            % Flow velocity at COM
            [th_pred,phi_pred,r_pred] = cart2sph(u_prey,...
                                                 v_prey,...
                                                 w_prey);
            % Calculate angles of predicted vector
%             [th_pred,phi_pred,r_pred] = cart2sph(vect_norm(i_norm,1),...
%                                                  vect_norm(i_norm,2),...
%                                                  vect_norm(i_norm,3));
            
            % Calculate angles of measured direction vector
            [th_meas,phi_meas,r_meas] = cart2sph(prey_dir(j,1),...
                                                 prey_dir(j,2),...
                                                 prey_dir(j,3));   
            % Calcuate angles of prey position
            [az_prey,el_prey,r_prey] = cart2sph(prey_pos(j,1),...
                                                prey_pos(j,2),...
                                                prey_pos(j,3));
            
            % Store result
            r.pred_spd(seqs(j)) = spds(i);                                
%             r.th_pred(seqs(j))  = th_pred *180/pi;
%             r.phi_pred(seqs(j)) = phi_pred*180/pi;
            r.th_meas(seqs(j))  = th_meas*180/pi;
            r.phi_meas(seqs(j)) = phi_meas*180/pi;
            r.az_prey(seqs(j))  = az_prey*180/pi;
            r.el_prey(seqs(j))  = el_prey*180/pi;
            r.th_pred(seqs(j))  = th_pred *180/pi;
            r.phi_pred(seqs(j)) = phi_pred *180/pi;
            r.wrong(seqs(j))    = i_wrong(j);
            r.vent(seqs(j))     = i_vent(j);
            
            
            % Visulaize this step (to confirm calculations
            if vis_seqs
                % Isosurface of speed
                p = patch('Vertices', verts, 'Faces', faces, ...
                    'FaceColor','interp', ...
                    'edgecolor', 'interp');
                set(p,'FaceColor','red','EdgeColor','none');
                daspect([1,1,1])
                %view(3);
                axis tight
                camlight
                lighting gouraud
                alpha(p,alpha_val)
                hold on
                
%                 quiver3(prey_pos(j,1),prey_pos(j,2),prey_pos(j,3),...
%                         xPredict,yPredict,zPredict,0.3,'b')
                
%                 % Normal vectors
%                 hq = quiver3(pos_norm(:,1),pos_norm(:,2),pos_norm(:,3),...
%                     vect_norm(:,1),vect_norm(:,2),vect_norm(:,3),1,'k');
%                 set(hq,'Color',.5.*[1 1 1])
                
%                 % Highlight closest normal vector
%                 quiver3(pos_norm(i_norm,1),pos_norm(i_norm,2),pos_norm(i_norm,3),...
%                     vect_norm(i_norm,1),vect_norm(i_norm,2),vect_norm(i_norm,3),.2,'k');
                %quiver3
                
                % Plot prey direction
                quiver3(prey_pos(j,1),prey_pos(j,2),prey_pos(j,3),...
                        prey_dir(j,1),prey_dir(j,2),prey_dir(j,3),1,'r')
                      
                
                clear p
            end
            
            % Clear variables
            clear spd_prey faces verts pos_norm vect_nor dist i_norm th_pred
            clear phi_pred r_pred th_meas phi_meas r_meas
            
        end
        
        if vis_seqs
            title([num2str(spds(i)) ' cm/s'])
            xlabel('x')
            ylabel('y')
            zlabel('z')
            %view(2)
            view([0 180])
        end
        
        
        % Clear for next speed
        clear cR prey_dir prey_pos lat_offset idx prey_dir
        
        disp(' ');disp(['Done ' num2str(spds(i)) ' cm/s'])
        
    end % Loop for each speed
    
    % Save cue analysis data
    save([root_path filesep 'flow cue analysis'],'r')
 
else
    % Load previous 'r' 
    load([root_path filesep 'flow cue analysis'])
    
end % do_direction


%% Visualize direction cue results

if vis_directcue
    
    
    figure;
    
    % Plot results
    subplot(2,2,1)
    
    
    inc{1} = index{1} & ~r.vent & ~r.wrong;
    inc{2} = index{2} & ~r.vent & ~r.wrong;
    inc{3} = index{3} & ~r.vent & ~r.wrong;
    
    
    scatter_plot(r.th_pred,r.th_meas,inc)
    
    xlabel('az of velocity at COM (dorsal)')
    ylabel('az of response ')
    
    subplot(2,2,2)
    
    inc{1} = index{1} & r.vent & ~r.wrong;
    inc{2} = index{2} & r.vent & ~r.wrong;
    inc{3} = index{3} & r.vent & ~r.wrong;
    
    scatter_plot(r.th_pred,r.th_meas,inc)
    
    xlabel('az of velocity at COM (ventral)')
    ylabel('az of response ')
    
    
    subplot(2,2,3)
    
    inc{1} = index{1} & ~r.vent;
    inc{2} = index{2} & ~r.vent;
    inc{3} = index{3} & ~r.vent;
    
    scatter_plot(r.phi_pred,r.phi_meas,inc)
    
    xlabel('el of velocity at COM (dorsal)')
    ylabel('el of response')
    
    
    subplot(2,2,4)
    
    inc{1} = index{1} & r.vent;
    inc{2} = index{2} & r.vent;
    inc{3} = index{3} & r.vent;
    
    scatter_plot(r.phi_pred,r.phi_meas,inc)
    
    xlabel('el of velocity at COM (ventral)')
    ylabel('el of response')
    
end


%% Analyze direction wrt flow differences along the body

if do_bodycue
    
    % Initialize result vectors
    r.pred_spd  = nan(size(b.preyx(:,1),1),1);
    r.spd_rost  = nan(size(b.preyx(:,1),1),1);
    r.spd_tail  = nan(size(b.preyx(:,1),1),1);
    r.spd_right = nan(size(b.preyx(:,1),1),1);
    r.spd_left  = nan(size(b.preyx(:,1),1),1);
    r.spd_dors  = nan(size(b.preyx(:,1),1),1);
    r.spd_vent  = nan(size(b.preyx(:,1),1),1);
    r.az_dir    = nan(size(b.preyx(:,1),1),1);
    r.el_dir    = nan(size(b.preyx(:,1),1),1);
    r.wrongLR   = zeros(size(b.preyx(:,1),1),1);
    r.wrongDV   = zeros(size(b.preyx(:,1),1),1);
    r.vent      = zeros(size(b.preyx(:,1),1),1);
    
    if vis_seqs
        figure;
    end
    
    % Loop through speeds
    for i = 1:3
        
        if vis_seqs
            figure;
        end
        
        % Load CFD data in 'cR' structure
        load(cfd_path{i})
        
        % Choose index for sequences that have stage 2 data
        idx = index{i} & ~isnan(b.preyx2(:,2)) & b.preyx(:,1)>0  ...
              & b.preyx(:,2)>0  & b.preyx(:,3)>0;
        
        % Sequence numbers 
        seqs = find(idx);
        
        % Get body points for all sequences in current speed
        [rost0,com0,tail0,rost1,com1,tail1,rost2,com2,tail2,i_vent,...
         i_wrongLR,i_wrongDV,prey_dir] = give_points(b,idx,latency,spds(i));
        
        % Index of individuals positioned ventral to predator
        i_vent = com0(:,3)<=0;
        
        % Index of all wrong directions based on distance from axis 
        % extending from predator midline (Bill)
        
        %calculate dist from mildline at t1 and t2
        dist1 = (com1(:,2).^2 + com1(:,3).^2).^0.5;
        dist2 = (com2(:,2).^2 + com2(:,3).^2).^0.5;
        
        %those going in wrong direction have smaller d2 
        i_wrong = dist2 < dist1;
       
        % Step thru each sequence for current speed
        for j = 1:length(seqs)

            % Body length of prey
            blength = norm([tail0(j,1)-rost0(j,1) ...
                            tail0(j,2)-rost0(j,2) ...
                            tail0(j,3)-rost0(j,3)]);       
                        
            % Range of volume to interrogate
            rangeX   = [com0(j,1)-blength*sclfactr_bod ...
                        com0(j,1)+blength*sclfactr_bod];
            rangeY   = [com0(j,2)-blength*sclfactr_bod ...
                        com0(j,2)+blength*sclfactr_bod];
            rangeZ   = [com0(j,3)-blength*sclfactr_bod ...
                        com0(j,3)+blength*sclfactr_bod];
            subRange = [rangeX(1) rangeX(2) ...
                        rangeY(1) rangeY(2) ...
                        rangeZ(1) rangeZ(2)];
            
            % Reduce flow field to small volume
            [xS,yS,zS,spdS] = subvolume(cR.x,cR.y,cR.z,cR.spd,subRange);
            %[xS,yS,zS,uS] = subvolume(cR.x,cR.y,cR.z,cR.u,subRange);
            %[xS,yS,zS,vS] = subvolume(cR.x,cR.y,cR.z,cR.v,subRange);
            %[xS,yS,zS,wS] = subvolume(cR.x,cR.y,cR.z,cR.w,subRange);

            clear rangeX rangeY rangeZ subRange

            % Points on the L and R of the body
            l_ptL = [blength/2 -blength/10 0];
            r_ptL = [blength/2  blength/10 0];
            d_ptL = [blength/2  0 blength/10];
            v_ptL = [blength/2  0 -blength/10];
            
            % L and R points transformed into global cooridnate system
            l_pt = local_to_global(rost0(j,:),com0(j,:),tail0(j,:),l_ptL);
            r_pt = local_to_global(rost0(j,:),com0(j,:),tail0(j,:),r_ptL);
            d_pt = local_to_global(rost0(j,:),com0(j,:),tail0(j,:),d_ptL);
            v_pt = local_to_global(rost0(j,:),com0(j,:),tail0(j,:),v_ptL);
            
            % Package points for griddata
            pnts = [l_pt; r_pt; rost0(j,:); tail0(j,:); d_pt; v_pt];
            
            % Interpolate for speed 
            spd_vals = griddata(xS,yS,zS,spdS,pnts(:,1),pnts(:,2),pnts(:,3));

            % Speed values at differ spots on the body
            spd_left  = spd_vals(1);
            spd_right = spd_vals(2);  
            spd_rost  = spd_vals(3);
            spd_tail  = spd_vals(4);
            spd_dors  = spd_vals(5);
            spd_vent  = spd_vals(6);

            % Transform direction wrt prey body
            com2L = global_to_local(rost1(j,:),com1(j,:),tail1(j,:),com2(j,:));
            com1L = global_to_local(rost1(j,:),com1(j,:),tail1(j,:),com1(j,:));
            
            % Calculate response direction from local FOR
            prey_dirL(:,1) = com2L(:,1) - com1L(:,1);
            prey_dirL(:,2) = com2L(:,2) - com1L(:,2);
            prey_dirL(:,3) = com2L(:,3) - com1L(:,3);
            
            % Angle of response wrt body
            [az_dir,el_dir,r_dir] = cart2sph(prey_dirL(1),prey_dirL(2),prey_dirL(3));
            
            % Current sequence
            sq = seqs(j);
            
            % Store results
            r.pred_spd(sq,1)  = spds(i);
            r.spd_rost(sq,1)  = spd_rost;
            r.spd_tail(sq,1)  = spd_tail;
            r.spd_right(sq,1) = spd_right;
            r.spd_left(sq,1)  = spd_left;
            r.spd_dors(sq,1)  = spd_dors;
            r.spd_vent(sq,1)  = spd_vent;
            r.az_dir(sq,1)    = az_dir;
            r.el_dir(sq,1)    = el_dir;
            r.vent(sq,1)      = i_vent(j);
            r.wrong(sq,1)     = i_wrong(j);
            
            if vis_seqs
                plot3([rost1(j,1) tail1(j,1)], ...
                    [rost1(j,2) tail1(j,2)], ...
                    [rost1(j,3) tail1(j,3)],'k',...
                    rost1(j,1),rost1(j,2),rost1(j,3),'ok')
                hold on
                arrow3(com1(j,:),com2(j,:),'r')
                axis equal
                title(['az_dir = ' num2str(az_dir*180/pi) ' deg'])
                xlabel('x');ylabel('y');zlabel('z')
            end
        
        end
        
        
        disp(' ');disp(['Done ' num2str(spds(i)) ' cm/s'])
        
    end % Loop for each speed
    
    % Save cue analysis data
    save([root_path filesep 'bodycue data'],'r')
 
else
    % Load previous 'r' 
    load([root_path filesep 'bodycue data'])
    
end % do_bodycue


%% Visulize rose plots of direction wrt body

if vis_rose

    % Plot direction (az) for rostrum/tail comparisons   
    %rose_wrt_body(b,r,num_bin,index,r.spd_rost,r.spd_tail,'rost','tail','az')
    
    % Plot direction (az) for left/right comparisons    
    %rose_wrt_body(b,r,num_bin,index,r.spd_right,r.spd_left,'right','left','az')
        
    % Plot direction (az) for left/right comparisons with new 'wrong' calc (Bill)   
    rose_wrt_body(b,r,num_bin,index,r.spd_right,r.spd_left,'right','left','both')
    
    % Plot direction (el) for dorsal/ventral comparisons    
    %rose_wrt_body(b,r,num_bin,index,r.spd_dors,r.spd_vent,'dors','vent','el')

    
end % vis_rose


%% Simulate response direction assuming 90 degree direction

if do_simulate
   
    
    
    %step through speeds
    for i = 2:3

        
        %Lateral simulations
        
        % Choose index for sequences that have stage 2 data
        idx = index{i} & ~isnan(b.preyx2(:,2));
        
        
        [rost0,com0,tail0,rost1,com1,tail1,rost2,com2,tail2,i_vent,...
            i_wrongLR,i_wrongDV,prey_dir] = give_points2(b,idx,latency,spds(i));
        
        %determine groups based on lateral position
        idx_l =  (com1(:,2) > 0.5);
        idx_m =  (com1(:,2) < 0.5);
            
        
        %determine prey dir in global coords
        body_dir = rost1 - tail1;
        body_dir_polar = cart2pol(body_dir(:,1),body_dir(:,2));        
        
        spd_left = r.spd_left(idx,1);
        spd_right = r.spd_right(idx,1);
        
        %now calculate predicted azimuth
        %higher on left if positive
        spd_diff = spd_left - spd_right;
        
        sim_dir = nan(length(idx_l),1);
        
        sim_dir(spd_diff > 0) = body_dir_polar(spd_diff > 0) - (pi/2);
        sim_dir(spd_diff < 0) = body_dir_polar(spd_diff < 0) + (pi/2);
        
        
        rose(sim_dir(idx_l));
        
        
        
        
        
        
        
        
        %Lateral Simulations
    
    
    
    
    end
    
    
    
end


%% Visualize local flow
% Visualize results of this anlaysis by running vis_3D with do_localflow = 1;

if do_localflow
    
    % Number of points along the x-axis of the body
    num_xpts = 20;
    
    % Range of points along x-axis of body (in body lengths)
    x_rangeL = [-.5 1.5];
    
    % Range of points along y-axis of body (in body lengths)
    y_rangeL = [-0.5 0.5];
    
    % Range of points along the z-axis of body (in body lengths)
    z_rangeL = [-.5 .5];
    
    % Initialize result vectors
    
    nan1  = nan(size(b.preyx(:,1),1),1);
    nan3  = nan(size(b.preyx(:,1),1),3);
    cell1 = cell(size(b.preyx(:,1),1),1);
    
    L.pred_spd = nan1;
    L.rost0    = nan3;
    L.com0     = nan3;
    L.tail0    = nan3;
    L.rost1    = nan3;
    L.com1     = nan3;
    L.tail1    = nan3;
    L.rost2    = nan3;
    L.com2     = nan3;
    L.tail2    = nan3;
    L.front    = cell1;
    L.sag      = cell1;
    L.dirL     = nan3;
    L.az_dirL  = nan1;
    L.el_dirL  = nan1;
    L.wrong    = nan1;
    
    clear nan1 nan3
    
    % Loop through speeds
    for i = 1:3
        
        
        % Load CFD data in 'cR' structure
        load(cfd_path{i})
        
        % Choose index for sequences that have stage 2 data
        idx = index{i} & ~isnan(b.preyx2(:,2)) & b.preyx(:,1)>0  ...
              & b.preyx(:,2)>0  & b.preyx(:,3)>0;
        
        % Sequence numbers 
        seqs = find(idx);
        
        % Get body points for all sequences in current speed
        [rost0,com0,tail0,rost1,com1,tail1,rost2,com2,tail2,i_vent,...
         i_wrongLR,i_wrongDV,prey_dir] = give_points(b,idx,latency,spds(i));
        
        % Index of individuals positioned ventral to predator
        i_vent = com0(:,3)<=0;
        
        % Index of all wrong directions based on distance from axis 
        % extending from predator midline (Bill)
        
        %calculate dist from mildline at t1 and t2
        dist1 = (com1(:,2).^2 + com1(:,3).^2).^0.5;
        dist2 = (com2(:,2).^2 + com2(:,3).^2).^0.5;
        
        %those going in wrong direction have smaller d2 
        i_wrong = dist2 < dist1;
        
        clear dist1 dist2
        
                
        % Step thru each sequence for current speed
        for j = 1:length(seqs)

            % Body length of prey
            blength = norm([tail0(j,1)-rost0(j,1) ...
                            tail0(j,2)-rost0(j,2) ...
                            tail0(j,3)-rost0(j,3)]);       
                        
            % Range of volume to interrogate
            rangeX   = [com0(j,1)-blength*sclfactr_bod ...
                        com0(j,1)+blength*sclfactr_bod];
            rangeY   = [com0(j,2)-blength*sclfactr_bod ...
                        com0(j,2)+blength*sclfactr_bod];
            rangeZ   = [com0(j,3)-blength*sclfactr_bod ...
                        com0(j,3)+blength*sclfactr_bod];
            subRange = [rangeX(1) rangeX(2) ...
                        rangeY(1) rangeY(2) ...
                        rangeZ(1) rangeZ(2)];
            
            % Reduce flow field to small volume
            [xS,yS,zS,uS]   = subvolume(cR.x,cR.y,cR.z,cR.u,subRange);
            [xS,yS,zS,vS]   = subvolume(cR.x,cR.y,cR.z,cR.v,subRange);
            [xS,yS,zS,wS]   = subvolume(cR.x,cR.y,cR.z,cR.w,subRange);

            
            clear rangeX rangeY rangeZ subRange
            
            % Define points for the frontal plane of the body
            x_valsF = linspace(blength*x_rangeL(1),...
                               blength*x_rangeL(2),...
                               num_xpts)';
            y_valsF = [blength*y_rangeL(1):...
                       mean(diff(x_valsF)):...
                       blength*y_rangeL(2)]';
            
            % Define points for the saggital plane of the body
            x_valsS = x_valsF;
            z_valsS = [blength*z_rangeL(1):...
                       mean(diff(x_valsS)):...
                       blength*z_rangeL(2)]';
            
            % Meshgrid the frontal and saggital plane coordinates
            [x2F,y2F,z2F] = meshgrid(x_valsF,y_valsF,0);
            [x2S,y2S,z2S] = meshgrid(x_valsS,0,z_valsS);
            
            % Transform coordinates from local to global systems
            [xptsF,yptsF,zptsF] = local_to_global_matrix(rost0(j,:),...
                                      com0(j,:),tail0(j,:),x2F,y2F,z2F);
            [xptsS,yptsS,zptsS] = local_to_global_matrix(rost0(j,:),...
                                      com0(j,:),tail0(j,:),x2S,y2S,z2S);
                                  
            % Interpolate to get flow velocities (frontal plane)                   
            gbl_uF   = griddata(xS,yS,zS,uS,xptsF,yptsF,zptsF);
            gbl_vF   = griddata(xS,yS,zS,vS,xptsF,yptsF,zptsF);
            gbl_wF   = griddata(xS,yS,zS,wS,xptsF,yptsF,zptsF);
            
            % Interpolate to get flow velocities (saggital plane)                   
            gbl_uS   = griddata(xS,yS,zS,uS,xptsS,yptsS,zptsS);
            gbl_vS   = griddata(xS,yS,zS,vS,xptsS,yptsS,zptsS);
            gbl_wS   = griddata(xS,yS,zS,wS,xptsS,yptsS,zptsS);
            
            clear xptsF yptsF zptsF xptsS yptsS zptsS
             
            % Calculate speed
            gbl_spdF = sqrt(gbl_uF.^2 + gbl_vF.^2 + gbl_wF.^2);
            gbl_spdS = sqrt(gbl_uS.^2 + gbl_vS.^2 + gbl_wS.^2);
            
            % Transform velocities back to local system           
            [uF,vF,wF] = global_to_local_flow(rost0(j,:),...
                              com0(j,:),tail0(j,:),...
                              xptsF,yptsF,zptsF,...
                              gbl_uF,gbl_vF,gbl_wF);
                          
            [uS,vS,wS] = global_to_local_flow(rost0(j,:),...
                              com0(j,:),tail0(j,:),...
                              xptsS,yptsS,zptsS,...
                              gbl_uS,gbl_vS,gbl_wS);
                          
            clear gbl_uF gbl_vF gbl_wF gbl_uS gbl_vS gbl_wS
                          
            % Transform fast start direction wrt prey body
            com2L = global_to_local(rost1(j,:),com1(j,:),tail1(j,:),com2(j,:));
            com1L = global_to_local(rost1(j,:),com1(j,:),tail1(j,:),com1(j,:));
            
            % Calculate fast start direction from local FOR
            prey_dirL(:,1) = com2L(:,1) - com1L(:,1);
            prey_dirL(:,2) = com2L(:,2) - com1L(:,2);
            prey_dirL(:,3) = com2L(:,3) - com1L(:,3);  
            
            % Angle of response wrt body
            [az_dir,el_dir,r_dir] = cart2sph(prey_dirL(1),...
                                             prey_dirL(2),prey_dirL(3));
            
            % Reshape all of the saggital plane points
            new_dim  = [size(x2S,2) size(x2S,3) size(x2S,1)];
            x2S      = reshape(x2S,new_dim);
            y2S      = reshape(y2S,new_dim);
            z2S      = reshape(z2S,new_dim);
            uS       = reshape(uS,new_dim);
            vS       = reshape(vS,new_dim);
            wS       = reshape(wS,new_dim);
            gbl_spdS = reshape(gbl_spdS,new_dim);
                
            if vis_seqs
                figure
                
                % Plot frontal plane
                surf(x2F,y2F,z2F,gbl_spdF)
                axis equal
                shading interp;
                hold on
                h = quiver3(x2F,y2F,z2F,uF,vF,wF,0.5,'k');
                
                % Plot saggital plane
                surf(x2S,y2S,z2S,gbl_spdS)
                h = quiver3(x2S,y2S,z2S,uS,vS,wS,0.5,'k');
                
                % Plot response vector
                h = arrow3([0 0 0],prey_dirL,'k',.5,.5);
                set(h(1),'LineWidth',2)
                shading interp;
                
                colorbar('South')
                title([num2str(spds(i)) ' cm/s, seq ' num2str(seqs(j))])
                
                %k = waitforbuttonpress;
                %close
            end

            % Current sequence
            sq = seqs(j);
            
            % Store results--------------------------
            
            % Predator speed
            L.pred_spd(sq,1)  = spds(i);
            
            % Prey coordinates (global system)
            L.rost0(sq,:) = rost0(j,:);
            L.com0(sq,:)  = com0(j,:);
            L.tail0(sq,:) = tail0(j,:);
            L.rost1(sq,:) = rost1(j,:);
            L.com1(sq,:)  = com1(j,:);
            L.tail1(sq,:) = tail1(j,:);
            L.rost2(sq,:) = rost2(j,:);
            L.com2(sq,:)  = com2(j,:);
            L.tail2(sq,:) = tail2(j,:);
            
            % Front plane flow (local system)
            L.front{sq}.xL  = x2F;
            L.front{sq}.yL  = y2F;
            L.front{sq}.zL  = z2F;
            L.front{sq}.uL  = uF;
            L.front{sq}.vL  = vF;
            L.front{sq}.wL  = wF;
            L.front{sq}.spd = gbl_spdF;
            
            % Saggital plane flow (local system)
            L.sag{sq}.xL  = x2S;
            L.sag{sq}.yL  = y2S;
            L.sag{sq}.zL  = z2S;
            L.sag{sq}.uL  = uS;
            L.sag{sq}.vL  = vS;
            L.sag{sq}.wL  = wS;
            L.sag{sq}.spd = gbl_spdS;
            
            % Prey response
            L.dirL(sq,:)    = prey_dirL;  
            L.az_dirL(sq,1) = az_dir;
            L.el_dirL(sq,1) = el_dir;
            L.wrong(sq,1)   = i_wrong(j);   
            
            clear x2F y2F z2F uF vF wF gbl_spdF prey_dirL az_dir el_dir
            clear gbl_spdF gbl_spdS x2S y2S z2S uS vS wS
            
            
            % Update on sequences
            disp(['      Done ' num2str(j) ' of ' num2str(length(seqs)) ...
                  ' sequences']);

        end
        
        % Update on speeds
        disp(' ');disp(['Done ' num2str(spds(i)) ' cm/s']);disp(' ')
        
    end % Loop for each speed
    
    % Save cue analysis data
    save([root_path filesep 'behavior' filesep 'localflow data'],'L')
 
else
    % Load previous 'L' 
    load([root_path filesep 'behavior' filesep 'localflow data'])
    
end % do_bodycue






function rose_wrt_body(b,r,num_bin,index,spd1,spd2,txt1,txt2,angl)
% Creates rose plots of response diretcion wrt the prey body for different
% categories that are defined by differences in flow along two regions of
% the body
      
figure

% Speed values
spds = [2 11 20];
    
if strcmp(angl,'both') %Bill's addition
    dir = r.az_dir;
    wrong = r.wrong;
    
else
    error('unrecognized "angle" input -- should be "az" or "el" or "both"')
end
    
% Loop through speeds
for i = 1:3
    
    % Index for directional responses in the 'correct' direction, where
    % spd1 > spd2
    idx = index{i} & ~isnan(b.preyx2(:,2)) & ...
        ~wrong & spd1>spd2;
    
    % Plot results
    subplot(2,3,i) 
    rose(dir(idx),num_bin)
    title([num2str(spds(i)) ' cm/s ' txt1 ' > ' txt2])
    hold on
    xlabel(angl)
    
    % Index for directional responses in the 'incorrect' direction, where
    % spd1 > spd2
    idx = index{i} & ~isnan(b.preyx2(:,2)) & ...
          wrong & spd1>spd2;
    
    % Plot
    hR = rose(dir(idx),num_bin);
    set(hR,'Color','r')
    
    pause(0.1);
    
    % Index for directional responses in the 'correct' direction, where
    % spd1 < spd2
    idx = index{i} & ~isnan(b.preyx2(:,2)) &  ...
          ~wrong & spd1<spd2;
          
    
    % Plot results
    subplot(2,3,3+i)
    rose(dir(idx),num_bin)
    title([num2str(spds(i)) ' cm/s ' txt1 ' < ' txt2])
    xlabel(angl)
    hold on
    
    % Index for directional responses in the 'incorrect' direction, where
    % spd1 < spd2
    idx = index{i} & ~isnan(b.preyx2(:,2)) &  ...
          wrong & spd1<spd2;
    
    % Plot
    hR = rose(dir(idx),num_bin);
    set(hR,'Color','r')
    
    pause(0.1);
end

pause(0.1)


function ptsT = global_to_local(rost,com,tail,pts)
% Transforms coordinates (pts, in n x 3) from global to local coordinate
% system, assuming the y-axis of larvae runs perpendicular to gravity

% Check dimensions
if size(rost,1)~=1 || size(rost,2)~=3 || size(com,1)~=1 | size(com,2)~=3 ...
   size(tail,1)~=1 || size(tail,2)~=3 || size(pts,2)~=3 
    error('inputs have incorrect dimensions')
end

% Retrieve local x axis to determine coordinate system
xaxis(1,1) = tail(1) - rost(1);
xaxis(1,2) = tail(2) - rost(2);
xaxis(1,3) = tail(3) - rost(3);

% Normalize to create a unit vector
xaxis = xaxis./norm(xaxis);

%Determine local y axis
%Short hand of cross product of inertial z axis and local x axis
yaxis = [-xaxis(2) xaxis(1) 0];

% Normalize to create a unit vector
yaxis = yaxis./norm(yaxis);

%Determine local z axis
zaxis = cross(xaxis,yaxis);

% Normalize to create a unit vector
zaxis = zaxis./norm(zaxis);

%Create rotation matrix (from inertial axes to local axes)
R = [xaxis' yaxis' zaxis'];

% Translate global coordinates wrt rostrum
ptsT(:,1) = pts(:,1) - rost(1);
ptsT(:,2) = pts(:,2) - rost(2);
ptsT(:,3) = pts(:,3) - rost(3);

% Rotate points
ptsT = [inv(R) * ptsT']';

% Visualize to test
if 0
    
    blength = norm([tail(1)-rost(1) tail(2)-rost(2) tail(3)-rost(3)]);    
    
    figure
    
    subplot(2,2,[1 3])
    plot3([tail(1) rost(1)],[tail(2) rost(2)],[tail(3) rost(3)],'b',...
          rost(1),rost(2),rost(3),'bo');
    hold on
    plot3(pts(:,1),pts(:,2),pts(:,3),'ro')
    xlabel('x'); ylabel('y'); zlabel('z')
    hold off
    grid on;axis equal
    view(3)
    title('global')
    
    subplot(2,2,2)
    plot([0 blength],[0 0],'b',0,0,'ob',ptsT(:,1),ptsT(:,2),'ro')
    xlabel('x');ylabel('y')
    grid on; axis equal
    title('local')
    
    subplot(2,2,4)
    plot([0 blength],[0 0],'b',0,0,'ob',ptsT(:,1),ptsT(:,3),'ro')
    xlabel('x');ylabel('z')
    grid on; axis equal
end


function ptsT = local_to_global(rost,com,tail,pts)
% Transforms coordinates (pts, in n x 3) from global to local coordinate
% system, assuming the y-axis of larvae runs perpendicular to gravity

% Check dimensions of landmark coordinates
if size(rost,1)~=1 || size(rost,2)~=3 || size(com,1)~=1 | size(com,2)~=3 ...
   size(tail,1)~=1 || size(tail,2)~=3
    error('inputs have incorrect dimensions')
end

% Retrieve local x axis to determine coordinate system
xaxis(1,1) = tail(1) - rost(1);
xaxis(1,2) = tail(2) - rost(2);
xaxis(1,3) = tail(3) - rost(3);

% Normalize to create a unit vector
xaxis = xaxis./norm(xaxis);

%Determine local y axis
%Short hand of cross product of inertial z axis and local x axis
yaxis = [-xaxis(2) xaxis(1) 0];

% Normalize to create a unit vector
yaxis = yaxis./norm(yaxis);

%Determine local z axis
zaxis = cross(xaxis,yaxis);

% Normalize to create a unit vector
zaxis = zaxis./norm(zaxis);

%Create rotation matrix (from inertial axes to local axes)
R = [xaxis' yaxis' zaxis'];

% If points are not meshgridded
if size(pts,2)==3
    % Rotate points
    ptsT = [R * pts']';
    
    % Translate global coordinates wrt rostrum
    ptsT(:,1) = ptsT(:,1) + rost(1);
    ptsT(:,2) = ptsT(:,2) + rost(2);
    ptsT(:,3) = ptsT(:,3) + rost(3);
    
else
    error('points need to be arranged in 3 columns')
    
end

% Visualize to test
if 0
    
    blength = norm([tail(1)-rost(1) tail(2)-rost(2) tail(3)-rost(3)]);    
    
    figure
    
    subplot(2,2,[1 3])
    plot3([tail(1) rost(1)],[tail(2) rost(2)],[tail(3) rost(3)],'b',...
          rost(1),rost(2),rost(3),'bo');
    hold on
    plot3(ptsT(:,1),ptsT(:,2),ptsT(:,3),'ro')
    xlabel('x'); ylabel('y'); zlabel('z')
    hold off
    grid on;axis equal
    view(3)
    title('global')
    
    subplot(2,2,2)
    plot([0 blength],[0 0],'b',0,0,'ob',pts(:,1),pts(:,2),'ro')
    xlabel('x');ylabel('y')
    grid on; axis equal
    title('local')
    
    subplot(2,2,4)
    plot([0 blength],[0 0],'b',0,0,'ob',pts(:,1),pts(:,3),'ro')
    xlabel('x');ylabel('z')
    grid on; axis equal
end


function [xT,yT,zT] = global_to_local_matrix(rost,com,tail,xpts,ypts,zpts)
% Transforms coordinates (pts, in n x 3) from global to local coordinate
% system, assuming the y-axis of larvae runs perpendicular to gravity

% Check dimensions
if size(rost,1)~=1 || size(rost,2)~=3 || size(com,1)~=1 || size(com,2)~=3 ...
   size(tail,1)~=1 || size(tail,2)~=3 
    error('inputs have incorrect dimensions')
end

% Retrieve local x axis to determine coordinate system
xaxis(1,1) = tail(1) - rost(1);
xaxis(1,2) = tail(2) - rost(2);
xaxis(1,3) = tail(3) - rost(3);

% Normalize to create a unit vector
xaxis = xaxis./norm(xaxis);

%Determine local y axis
%Short hand of cross product of inertial z axis and local x axis
yaxis = [-xaxis(2) xaxis(1) 0];

% Normalize to create a unit vector
yaxis = yaxis./norm(yaxis);

%Determine local z axis
zaxis = cross(xaxis,yaxis);

% Normalize to create a unit vector
zaxis = zaxis./norm(zaxis);

%Create rotation matrix (from inertial axes to local axes)
R = [xaxis' yaxis' zaxis'];

% Translate global coordinates wrt rostrum
xptsT = xpts - rost(1);
yptsT = ypts - rost(2);
zptsT = zpts - rost(3);

% Rotate points
%ptsT = [inv(R) * ptsT']';

% Transformation
for i = 1:size(xptsT,2)
    
    for j = 1:size(xptsT,3)
        ptsT = [xptsT(:,i,j) yptsT(:,i,j) zptsT(:,i,j)];
        
        % Rotate points
        ptsT = [inv(R) * ptsT']';
        
        % Store
        xT(:,i,j) = ptsT(:,1);
        yT(:,i,j) = ptsT(:,2);
        zT(:,i,j) = ptsT(:,3);    
    end    
end


function [uT3,vT3,wT3] = global_to_local_flow(rost,com,tail,x,y,z,u,v,w)
% Transforms coordinates (pts, in n x 3) from global to local coordinate
% system, assuming the y-axis of larvae runs perpendicular to gravity

% Check dimensions
if size(rost,1)~=1 || size(rost,2)~=3 || size(com,1)~=1 || size(com,2)~=3 ...
   size(tail,1)~=1 || size(tail,2)~=3 
    error('inputs have incorrect dimensions')
end

% Retrieve local x axis to determine coordinate system
xaxis(1,1) = tail(1) - rost(1);
xaxis(1,2) = tail(2) - rost(2);
xaxis(1,3) = tail(3) - rost(3);

% Normalize to create a unit vector
xaxis = xaxis./norm(xaxis);

%Determine local y axis
%Short hand of cross product of inertial z axis and local x axis
yaxis = [-xaxis(2) xaxis(1) 0];

% Normalize to create a unit vector
yaxis = yaxis./norm(yaxis);

%Determine local z axis
zaxis = cross(xaxis,yaxis);

% Normalize to create a unit vector
zaxis = zaxis./norm(zaxis);

%Create rotation matrix (from inertial axes to local axes)
R = [xaxis' yaxis' zaxis'];

% Translate global coordinates wrt rostrum
uT = (x + u) - rost(1);
vT = (y + v) - rost(2);
wT = (z + w) - rost(3);

xT = x - rost(1);
yT = y - rost(2);
zT = z - rost(3);

% Rotate points
%ptsT = [inv(R) * ptsT']';

% Transformation
for i = 1:size(uT,2)
    
    for j = 1:size(uT,3)
        
        pts   = [xT(:,i,j) yT(:,i,j) zT(:,i,j)];
        vects = [uT(:,i,j) vT(:,i,j) wT(:,i,j)];
        
        % Rotate points
        vects = [inv(R) * vects']';
        pts   = [inv(R) * pts']';
        
        % Store vector components
        uT2(:,i,j) = vects(:,1);
        vT2(:,i,j) = vects(:,2);
        wT2(:,i,j) = vects(:,3);   
        
        % Store coordinates
        xT2(:,i,j) = pts(:,1);
        yT2(:,i,j) = pts(:,2);
        zT2(:,i,j) = pts(:,3);
    end    
end

uT3 = uT2 - xT2;
vT3 = vT2 - yT2;
wT3 = wT2 - zT2;




function [xptsT,yptsT,zptsT] = local_to_global_matrix(rost,com,tail,xpts,ypts,zpts)
% Transforms coordinates (pts, in n x 3) from global to local coordinate
% system, assuming the y-axis of larvae runs perpendicular to gravity

% Check dimensions of landmark coordinates
if size(rost,1)~=1 || size(rost,2)~=3 || size(com,1)~=1 | size(com,2)~=3 ...
   size(tail,1)~=1 || size(tail,2)~=3
    error('inputs have incorrect dimensions')
end

% Retrieve local x axis to determine coordinate system
xaxis(1,1) = tail(1) - rost(1);
xaxis(1,2) = tail(2) - rost(2);
xaxis(1,3) = tail(3) - rost(3);

% Normalize to create a unit vector
xaxis = xaxis./norm(xaxis);

%Determine local y axis
%Short hand of cross product of inertial z axis and local x axis
yaxis = [-xaxis(2) xaxis(1) 0];

% Normalize to create a unit vector
yaxis = yaxis./norm(yaxis);

%Determine local z axis
zaxis = cross(xaxis,yaxis);

% Normalize to create a unit vector
zaxis = zaxis./norm(zaxis);

%Create rotation matrix (from inertial axes to local axes)
R = [xaxis' yaxis' zaxis'];

% Transformation
for i = 1:size(xpts,2)
    
    for j = 1:size(xpts,3)
        pts = [xpts(:,i,j) ypts(:,i,j) zpts(:,i,j)];
        
        % Rotate points
        ptsT = [R * pts']';
        
        % Store
        xptsT(:,i,j) = ptsT(:,1) + rost(1);
        yptsT(:,i,j) = ptsT(:,2) + rost(2);
        zptsT(:,i,j) = ptsT(:,3) + rost(3);    
    end    
end



function scatter_plot(pred,meas,index)

% All predicted values
p_pool = [pred(index{1}) ; ...
          pred(index{2}) ;...
          pred(index{3}) ];
     
% Range of predicted values
pred_range = [min(p_pool) max(p_pool)];

% All measurements
m_pool = [meas(index{1}); ...
          meas(index{2}); ...
          meas(index{3})];

% Run regression on all data together
[c,cint,res,resint,stats] = regress(m_pool,[ones(length(p_pool),1) p_pool]);

plot(pred(index{1}),meas(index{1}),'ro',...
     pred(index{2}),meas(index{2}),'bo',...
     pred(index{3}),meas(index{3}),'go',...
     [pred_range(1) pred_range(2)],c(2).*[pred_range(1) pred_range(2)]+c(1),'k--');
 
 %[pred_range(1) pred_range(2)],[pred_range(1) pred_range(2)],'k-',...
 
title(['r2=' num2str(stats(1)) ' p=' num2str(stats(3))]) 
axis square
legend('2','11','20','Location','NorthWest') 

%gbl_spd = griddata(xS,yS,zS,spdS,xptsT,yptsT,zptsT);


function  [rost0,com0,tail0,rost1,com1,tail1,rost2,com2,tail2,i_vent,...
           i_wrongLR,i_wrongDV,prey_dir] = give_points(b,idx,latency,spd)
% Returns the points of the prey body for all sequences denoted by 'idx'
       
% Offset in x, due to latency
lat_offset = latency * spd;

% Position (wrt predator) of body points when flow sensed
rost0 = [b.preyx(idx,1)+lat_offset b.preyy(idx,1) b.preyz(idx,1)];
com0  = [b.preyx(idx,2)+lat_offset b.preyy(idx,2) b.preyz(idx,2)];
tail0 = [b.preyx(idx,3)+lat_offset b.preyy(idx,3) b.preyz(idx,3)];

% Position (wrt predator) of body points when larva first moves
rost1 = [b.preyx(idx,1) b.preyy(idx,1) b.preyz(idx,1)];
com1  = [b.preyx(idx,2) b.preyy(idx,2) b.preyz(idx,2)];
tail1 = [b.preyx(idx,3) b.preyy(idx,3) b.preyz(idx,3)];

% Position (wrt predator) of body points at end of stage 2
rost2 = [b.preyx2(idx,1) b.preyy2(idx,1) b.preyz2(idx,1)];
com2  = [b.preyx2(idx,2) b.preyy2(idx,2) b.preyz2(idx,2)];
tail2 = [b.preyx2(idx,3) b.preyy2(idx,3) b.preyz2(idx,3)];

% Find direction of response
prey_dir(:,1) = com2(:,1) - com1(:,1);
prey_dir(:,2) = com2(:,2) - com1(:,2);
prey_dir(:,3) = com2(:,3) - com1(:,3);

% Transform prey direction, assuming mirror symmetry about the predator
% prey_dir(com1(:,2)<0,2) = -prey_dir(com1(:,2)<0,2);

% % Transform body points, assuming mirror symmetry about the predator
% rost0(:,2)  = abs(rost0(:,2));
% com0(:,2)   = abs(com0(:,2));
% tail0(:,2)  = abs(tail0(:,2));
% 
% rost1(:,2)  = abs(rost1(:,2));
% com1(:,2)   = abs(com1(:,2));
% tail1(:,2)  = abs(tail1(:,2));
% 
% rost2(:,2)  = abs(rost2(:,2));
% com2(:,2)   = abs(com2(:,2));
% tail2(:,2)  = abs(tail2(:,2));

% Index of individuals positioned ventral to predator
i_vent = com0(:,3)<=0;

% Index of L-R responses in the 'wrong' direction
i_wrongLR = prey_dir(:,2)<0;

% Index of D-V responses in the 'wrong' direction
i_wrongDV = (i_vent & (prey_dir(:,3)>0)) |  ...
    (~i_vent & (prey_dir(:,3)<=0));


function  [rost0,com0,tail0,rost1,com1,tail1,rost2,com2,tail2,i_vent,...
           i_wrongLR,i_wrongDV,prey_dir] = give_points2(b,idx,latency,spd)
% Returns the points of the prey body for all sequences denoted by 'idx'
%this is different than give_pointd because mirror symmetry does not effect
%the negative values in front of predator


% Offset in x, due to latency
lat_offset = latency * spd;

% Position (wrt predator) of body points when flow sensed
rost0 = [b.preyx(idx,1)+lat_offset b.preyy(idx,1) b.preyz(idx,1)];
com0  = [b.preyx(idx,2)+lat_offset b.preyy(idx,2) b.preyz(idx,2)];
tail0 = [b.preyx(idx,3)+lat_offset b.preyy(idx,3) b.preyz(idx,3)];

% Position (wrt predator) of body points when larva first moves
rost1 = [b.preyx(idx,1) b.preyy(idx,1) b.preyz(idx,1)];
com1  = [b.preyx(idx,2) b.preyy(idx,2) b.preyz(idx,2)];
tail1 = [b.preyx(idx,3) b.preyy(idx,3) b.preyz(idx,3)];

% Position (wrt predator) of body points at end of stage 2
rost2 = [b.preyx2(idx,1) b.preyy2(idx,1) b.preyz2(idx,1)];
com2  = [b.preyx2(idx,2) b.preyy2(idx,2) b.preyz2(idx,2)];
tail2 = [b.preyx2(idx,3) b.preyy2(idx,3) b.preyz2(idx,3)];

% Find direction of response
prey_dir(:,1) = com2(:,1) - com1(:,1);
prey_dir(:,2) = com2(:,2) - com1(:,2);
prey_dir(:,3) = com2(:,3) - com1(:,3);

% Transform prey direction for those at y < -0.5, assuming mirror symmetry
%about the predator
prey_dir(com1(:,2)<-.5,2) = -prey_dir(com1(:,2)<-.5,2);

% Transform body points, assuming mirror symmetry about the predator for
% those positioned at y < -.5
rost0(com1(:,2)<-.5,2)  = abs(rost0(com1(:,2)<-.5,2));
com0(com1(:,2)<-.5,2)   = abs(com0(com1(:,2)<-.5,2));
tail0(com1(:,2)<-.5,2)  = abs(tail0(com1(:,2)<-.5,2));

rost1(com1(:,2)<-.5,2)  = abs(rost1(com1(:,2)<-.5,2));
com1(com1(:,2)<-.5,2)   = abs(com1(com1(:,2)<-.5,2));
tail1(com1(:,2)<-.5,2)  = abs(tail1(com1(:,2)<-.5,2));

rost2(com1(:,2)<-.5,2)  = abs(rost2(com1(:,2)<-.5,2));
com2(com1(:,2)<-.5,2)   = abs(com2(com1(:,2)<-.5,2));
tail2(com1(:,2)<-.5,2)  = abs(tail2(com1(:,2)<-.5,2));

% Index of individuals positioned ventral to predator
i_vent = com0(:,3)<=0;

% Index of L-R responses in the 'wrong' direction
i_wrongLR = prey_dir(:,2)<0;

% Index of D-V responses in the 'wrong' direction
i_wrongDV = (i_vent & (prey_dir(:,3)>0)) |  ...
    (~i_vent & (prey_dir(:,3)<=0));


function plot_prey_pos(f,spd_index)


idx = find(spd_index);
for i = 1:length(idx)
    plot3([f.xbod(idx(i),1) f.xbod(idx(i),end)],...
          [f.ybod(idx(i),1) f.ybod(idx(i),end)],...
          [f.zbod(idx(i),1) f.zbod(idx(i),end)],'-k',...
           f.xbod(idx(i),1),f.ybod(idx(i),1),f.zbod(idx(i),1),'ok');
    hold on
end
axis equal
xlims = xlim;

plot3([xlims(1) 0],[0 0],[0 0],'r-',0,0,0,'or')

grid on
hold off

xlabel('x')
ylabel('y')
zlabel('z')

view([0 90])


function [pos,vect_norm] = cal_norms(faces,verts)
% Finds the postion and direction of vectors normal to a 3D surface

% First vectors directed between verticies
vect1 = verts(faces(:,2),:)-verts(faces(:,1),:);

% Second vectors between verticies
vect2 = verts(faces(:,3),:)-verts(faces(:,1),:);

% Normal vectors
vect_norm = cross(vect2,vect1,2);

% Magnitude of normal vectors
norm_mag = sqrt(vect_norm(:,1).^2 + vect_norm(:,2).^2 + vect_norm(:,3).^2);

%Normalize the normal vectors
vect_norm = [vect_norm(:,1)./norm_mag ...
    vect_norm(:,2)./norm_mag ...
    vect_norm(:,3)./norm_mag];

% Position of normal vectors (centered btwn verticies)
pos(:,1) = mean([verts(faces(:,1),1) ...
    verts(faces(:,2),1) ...
    verts(faces(:,3),1)],2);
pos(:,2) = mean([verts(faces(:,1),2) ...
    verts(faces(:,2),2) ...
    verts(faces(:,3),2)],2);
pos(:,3) = mean([verts(faces(:,1),3) ...
    verts(faces(:,2),3) ...
    verts(faces(:,3),3)],2);


